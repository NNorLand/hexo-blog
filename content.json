[{"title":"JavaScript高阶函数","date":"2020-03-17T06:16:58.000Z","path":"2020/03/17/higher-func/","text":"高阶函数定义高阶函数英文叫 Higher-order function。高阶函数是对其他函数进行操作的函数，操作可以是将它们作为参数，或者返回它们。简单总结为高阶函数是一个接收函数作为参数或者将函数作为返回输出的函数。Array.prototype.map，Array.prototype.filter，Array.prototype.reduce和Array.prototype.sort是JavaScript中内置的高阶函数。它们接受一个函数作为参数，并应用这个函数到列表的每一个元素。下面是一些内置高阶函数的具体说明讲解，以及和不使用高阶函数情况下的对比12345678910111213let isString = obj =&gt; Object.prototype.toString.call( obj ) === '[object String]';let isArray = obj =&gt; Object.prototype.toString.call( obj ) === '[object Array]';let isNumber = obj =&gt; Object.prototype.toString.call( obj ) === '[object Number]';let isType = type =&gt; obj =&gt; &#123; return Object.prototype.toString.call( obj ) === '[object ' + type + ']';&#125;isType('String')('123'); // trueisType('Array')([1, 2, 3]); // trueisType('Number')(123); // true1234//JS实现一个无限累加的add函数add(1) //1 add(1)(2) //3add(1)(2)(3) //61234567891011121314function add(a) &#123; function sum(b) &#123; // 使用闭包 a = a + b; // 累加 return sum; &#125; sum.toString = function() &#123; // 重写toString()方法 return a; &#125; return sum; // 返回一个函数&#125;add(1); // 1add(1)(2); // 3add(1)(2)(3)； // 612345678910111213141516// 手动实现map函数const strArray=['JavaScript','PHP','JAVA','C','Python'];function mapForEach(arr,fn)&#123; const newArray = []; for(let i = 0; i&lt;arr.length;i++)&#123; newArray.push(&#123; fn(arr[i]) ); &#125; return newArray;&#125;const lenArray = mapForEach(strArray,function(item)&#123; return item.length;&#125;);console.log(lenArray);//[10,3,4,1,6]","updated":"2020-03-17T06:16:58.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"}]},{"title":"clean-code-javascript","date":"2020-01-21T09:13:30.000Z","path":"2020/01/21/JavaScript/clean-code-javascript/","text":"转载来自alivebao/clean-code-jsOriginal Repository: ryanmcdermott/clean-code-javascriptJavaScript 风格指南目录介绍变量函数对象和数据结构类测试并发错误处理格式化注释介绍作者根据 Robert C. Martin 《代码整洁之道》总结了适用于 JavaScript 的软件工程原则《Clean Code JavaScript》。本文是对其的翻译。不必严格遵守本文的所有原则，有时少遵守一些效果可能会更好，具体应根据实际情况决定。这是根据《代码整洁之道》作者多年经验整理的代码优化建议，但也仅仅只是一份建议。软件工程已经发展了 50 多年，至今仍在不断前进。现在，把这些原则当作试金石，尝试将他们作为团队代码质量考核的标准之一吧。最后你需要知道的是，这些东西不会让你立刻变成一个优秀的工程师，长期奉行他们也并不意味着你能够高枕无忧不再犯错。千里之行，始于足下。我们需要时常和同行们进行代码评审，不断优化自己的代码。不要惧怕改善代码质量所需付出的努力，加油。变量使用有意义，可读性好的变量名反例:1var yyyymmdstr = moment().format('YYYY/MM/DD');正例:1var yearMonthDay = moment().format('YYYY/MM/DD');回到目录使用 ES6 的 const 定义常量反例中使用”var”定义的”常量”是可变的。在声明一个常量时，该常量在整个程序中都应该是不可变的。反例:1var FIRST_US_PRESIDENT = \"George Washington\";正例:1const FIRST_US_PRESIDENT = \"George Washington\";回到目录对功能类似的变量名采用统一的命名风格反例:123getUserInfo();getClientData();getCustomerRecord();正例:1getUser();回到目录使用易于检索名称我们需要阅读的代码远比自己写的要多，使代码拥有良好的可读性且易于检索非常重要。阅读变量名晦涩难懂的代码对读者来说是一种相当糟糕的体验。让你的变量名易于检索。反例:1234// 525600 是什么?for (var i = 0; i &lt; 525600; i++) &#123; runCronJob();&#125;正例:12345// Declare them as capitalized `var` globals.var MINUTES_IN_A_YEAR = 525600;for (var i = 0; i &lt; MINUTES_IN_A_YEAR; i++) &#123; runCronJob();&#125;回到目录使用说明变量(即有意义的变量名)反例:12const cityStateRegex = /^(.+)[,\\\\s]+(.+?)\\s*(\\d&#123;5&#125;)?$/;saveCityState(cityStateRegex.match(cityStateRegex)[1], cityStateRegex.match(cityStateRegex)[2]);正例:123456const ADDRESS = 'One Infinite Loop, Cupertino 95014';var cityStateRegex = /^(.+)[,\\\\s]+(.+?)\\s*(\\d&#123;5&#125;)?$/;var match = ADDRESS.match(cityStateRegex)var city = match[1];var state = match[2];saveCityState(city, state);回到目录不要绕太多的弯子显式优于隐式。反例:12345678910var locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((l) =&gt; &#123; doStuff(); doSomeOtherStuff(); ... ... ... // l是什么？ dispatch(l);&#125;);正例:123456789var locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((location) =&gt; &#123; doStuff(); doSomeOtherStuff(); ... ... ... dispatch(location);&#125;);回到目录避免重复的描述当类/对象名已经有意义时，对其变量进行命名不需要再次重复。反例:123456789var Car = &#123; carMake: 'Honda', carModel: 'Accord', carColor: 'Blue'&#125;;function paintCar(car) &#123; car.carColor = 'Red';&#125;正例:123456789var Car = &#123; make: 'Honda', model: 'Accord', color: 'Blue'&#125;;function paintCar(car) &#123; car.color = 'Red';&#125;回到目录避免无意义的条件判断反例:12345678function createMicrobrewery(name) &#123; var breweryName; if (name) &#123; breweryName = name; &#125; else &#123; breweryName = 'Hipster Brew Co.'; &#125;&#125;正例:123function createMicrobrewery(name) &#123; var breweryName = name || 'Hipster Brew Co.'&#125;回到目录函数函数参数 (理想情况下应不超过 2 个)限制函数参数数量很有必要，这么做使得在测试函数时更加轻松。过多的参数将导致难以采用有效的测试用例对函数的各个参数进行测试。应避免三个以上参数的函数。通常情况下，参数超过两个意味着函数功能过于复杂，这时需要重新优化你的函数。当确实需要多个参数时，大多情况下可以考虑这些参数封装成一个对象。JS 定义对象非常方便，当需要多个参数时，可以使用一个对象进行替代。反例:123function createMenu(title, body, buttonText, cancellable) &#123; ...&#125;正例:12345678910var menuConfig = &#123; title: 'Foo', body: 'Bar', buttonText: 'Baz', cancellable: true&#125;function createMenu(menuConfig) &#123; ...&#125;回到目录函数功能的单一性这是软件功能中最重要的原则之一。功能不单一的函数将导致难以重构、测试和理解。功能单一的函数易于重构，并使代码更加干净。反例:12345678function emailClients(clients) &#123; clients.forEach(client =&gt; &#123; let clientRecord = database.lookup(client); if (clientRecord.isActive()) &#123; email(client); &#125; &#125;);&#125;正例:12345678910111213141516function emailClients(clients) &#123; clients.forEach(client =&gt; &#123; emailClientIfNeeded(client); &#125;);&#125;function emailClientIfNeeded(client) &#123; if (isClientActive(client)) &#123; email(client); &#125;&#125;function isClientActive(client) &#123; let clientRecord = database.lookup(client); return clientRecord.isActive();&#125;回到目录函数名应明确表明其功能反例:12345678function dateAdd(date, month) &#123; // ...&#125;let date = new Date();// 很难理解dateAdd(date, 1)是什么意思dateAdd(date, 1);正例:123456function dateAddMonth(date, month) &#123; // ...&#125;let date = new Date();dateAddMonth(date, 1);回到目录函数应该只做一层抽象当函数的需要的抽象多于一层时通常意味着函数功能过于复杂，需将其进行分解以提高其可重用性和可测试性。反例:12345678910111213141516171819202122function parseBetterJSAlternative(code) &#123; let REGEXES = [ // ... ]; let statements = code.split(' '); let tokens; REGEXES.forEach((REGEX) =&gt; &#123; statements.forEach((statement) =&gt; &#123; // ... &#125;) &#125;); let ast; tokens.forEach((token) =&gt; &#123; // lex... &#125;); ast.forEach((node) =&gt; &#123; // parse... &#125;)&#125;正例:1234567891011121314151617181920212223242526272829303132function tokenize(code) &#123; let REGEXES = [ // ... ]; let statements = code.split(' '); let tokens; REGEXES.forEach((REGEX) =&gt; &#123; statements.forEach((statement) =&gt; &#123; // ... &#125;) &#125;); return tokens;&#125;function lexer(tokens) &#123; let ast; tokens.forEach((token) =&gt; &#123; // lex... &#125;); return ast;&#125;function parseBetterJSAlternative(code) &#123; let tokens = tokenize(code); let ast = lexer(tokens); ast.forEach((node) =&gt; &#123; // parse... &#125;)&#125;回到目录移除重复的代码永远、永远、永远不要在任何循环下有重复的代码。这种做法毫无意义且潜在危险极大。重复的代码意味着逻辑变化时需要对不止一处进行修改。JS 弱类型的特点使得函数拥有更强的普适性。好好利用这一优点吧。反例:1234567891011121314151617181920212223242526272829function showDeveloperList(developers) &#123; developers.forEach(developer =&gt; &#123; var expectedSalary = developer.calculateExpectedSalary(); var experience = developer.getExperience(); var githubLink = developer.getGithubLink(); var data = &#123; expectedSalary: expectedSalary, experience: experience, githubLink: githubLink &#125;; render(data); &#125;);&#125;function showManagerList(managers) &#123; managers.forEach(manager =&gt; &#123; var expectedSalary = manager.calculateExpectedSalary(); var experience = manager.getExperience(); var portfolio = manager.getMBAProjects(); var data = &#123; expectedSalary: expectedSalary, experience: experience, portfolio: portfolio &#125;; render(data); &#125;);&#125;正例:123456789101112131415161718192021function showList(employees) &#123; employees.forEach(employee =&gt; &#123; var expectedSalary = employee.calculateExpectedSalary(); var experience = employee.getExperience(); var portfolio; if (employee.type === 'manager') &#123; portfolio = employee.getMBAProjects(); &#125; else &#123; portfolio = employee.getGithubLink(); &#125; var data = &#123; expectedSalary: expectedSalary, experience: experience, portfolio: portfolio &#125;; render(data); &#125;);&#125;回到目录采用默认参数精简代码反例:1234function writeForumComment(subject, body) &#123; subject = subject || 'No Subject'; body = body || 'No text';&#125;正例:123function writeForumComment(subject = 'No subject', body = 'No text') &#123; ...&#125;回到目录使用 Object.assign 设置默认对象反例:12345678910111213141516var menuConfig = &#123; title: null, body: 'Bar', buttonText: null, cancellable: true&#125;function createMenu(config) &#123; config.title = config.title || 'Foo' config.body = config.body || 'Bar' config.buttonText = config.buttonText || 'Baz' config.cancellable = config.cancellable === undefined ? config.cancellable : true;&#125;createMenu(menuConfig);正例:1234567891011121314151617181920var menuConfig = &#123; title: 'Order', // User did not include 'body' key buttonText: 'Send', cancellable: true&#125;function createMenu(config) &#123; config = Object.assign(&#123; title: 'Foo', body: 'Bar', buttonText: 'Baz', cancellable: true &#125;, config); // config now equals: &#123;title: \"Order\", body: \"Bar\", buttonText: \"Send\", cancellable: true&#125; // ...&#125;createMenu(menuConfig);回到目录不要使用标记(Flag)作为函数参数这通常意味着函数的功能的单一性已经被破坏。此时应考虑对函数进行再次划分。反例:1234567function createFile(name, temp) &#123; if (temp) &#123; fs.create('./temp/' + name); &#125; else &#123; fs.create(name); &#125;&#125;正例:12345678910function createTempFile(name) &#123; fs.create('./temp/' + name);&#125;----------function createFile(name) &#123; fs.create(name);&#125;回到目录避免副作用当函数产生了除了“接受一个值并返回一个结果”之外的行为时，称该函数产生了副作用。比如写文件、修改全局变量或将你的钱全转给了一个陌生人等。程序在某些情况下确实需要副作用这一行为，如先前例子中的写文件。这时应该将这些功能集中在一起，不要用多个函数/类修改某个文件。用且只用一个 service 完成这一需求。反例:1234567891011// Global variable referenced by following function.// If we had another function that used this name, now it'd be an array and it could break it.var name = 'Ryan McDermott';function splitIntoFirstAndLastName() &#123; name = name.split(' ');&#125;splitIntoFirstAndLastName();console.log(name); // ['Ryan', 'McDermott'];正例:123456789function splitIntoFirstAndLastName(name) &#123; return name.split(' ');&#125;var name = 'Ryan McDermott'var newName = splitIntoFirstAndLastName(name);console.log(name); // 'Ryan McDermott';console.log(newName); // ['Ryan', 'McDermott'];回到目录不要写全局函数在 JS 中污染全局是一个非常不好的实践，这么做可能和其他库起冲突，且调用你的 API 的用户在实际环境中得到一个 exception 前对这一情况是一无所知的。想象以下例子：如果你想扩展 JS 中的 Array，为其添加一个 diff 函数显示两个数组间的差异，此时应如何去做？你可以将 diff 写入 Array.prototype，但这么做会和其他有类似需求的库造成冲突。如果另一个库对 diff 的需求为比较一个数组中首尾元素间的差异呢？使用 ES6 中的 class 对全局的 Array 做简单的扩展显然是一个更棒的选择。反例:12345678910111213141516Array.prototype.diff = function(comparisonArray) &#123; var values = []; var hash = &#123;&#125;; for (var i of comparisonArray) &#123; hash[i] = true; &#125; for (var i of this) &#123; if (!hash[i]) &#123; values.push(i); &#125; &#125; return values;&#125;正例:12345678910111213141516171819202122class SuperArray extends Array &#123; constructor(...args) &#123; super(...args); &#125; diff(comparisonArray) &#123; var values = []; var hash = &#123;&#125;; for (var i of comparisonArray) &#123; hash[i] = true; &#125; for (var i of this) &#123; if (!hash[i]) &#123; values.push(i); &#125; &#125; return values; &#125;&#125;回到目录采用函数式编程函数式的编程具有更干净且便于测试的特点。尽可能的使用这种风格吧。反例:123456789101112131415161718192021const programmerOutput = [ &#123; name: 'Uncle Bobby', linesOfCode: 500 &#125;, &#123; name: 'Suzie Q', linesOfCode: 1500 &#125;, &#123; name: 'Jimmy Gosling', linesOfCode: 150 &#125;, &#123; name: 'Gracie Hopper', linesOfCode: 1000 &#125;];var totalOutput = 0;for (var i = 0; i &lt; programmerOutput.length; i++) &#123; totalOutput += programmerOutput[i].linesOfCode;&#125;正例:12345678910111213141516171819const programmerOutput = [ &#123; name: 'Uncle Bobby', linesOfCode: 500 &#125;, &#123; name: 'Suzie Q', linesOfCode: 1500 &#125;, &#123; name: 'Jimmy Gosling', linesOfCode: 150 &#125;, &#123; name: 'Gracie Hopper', linesOfCode: 1000 &#125;];var totalOutput = programmerOutput .map((programmer) =&gt; programmer.linesOfCode) .reduce((acc, linesOfCode) =&gt; acc + linesOfCode, 0);回到目录封装判断条件反例:123if (fsm.state === 'fetching' &amp;&amp; isEmpty(listNode)) &#123; /// ...&#125;正例:1234567function shouldShowSpinner(fsm, listNode) &#123; return fsm.state === 'fetching' &amp;&amp; isEmpty(listNode);&#125;if (shouldShowSpinner(fsmInstance, listNodeInstance)) &#123; // ...&#125;回到目录避免“否定情况”的判断反例:1234567function isDOMNodeNotPresent(node) &#123; // ...&#125;if (!isDOMNodeNotPresent(node)) &#123; // ...&#125;正例:1234567function isDOMNodePresent(node) &#123; // ...&#125;if (isDOMNodePresent(node)) &#123; // ...&#125;回到目录避免条件判断这看起来似乎不太可能。大多人听到这的第一反应是：“怎么可能不用 if 完成其他功能呢？”许多情况下通过使用多态(polymorphism)可以达到同样的目的。第二个问题在于采用这种方式的原因是什么。答案是我们之前提到过的：保持函数功能的单一性。反例:12345678910111213class Airplane &#123; //... getCruisingAltitude() &#123; switch (this.type) &#123; case '777': return getMaxAltitude() - getPassengerCount(); case 'Air Force One': return getMaxAltitude(); case 'Cessna': return getMaxAltitude() - getFuelExpenditure(); &#125; &#125;&#125;正例:123456789101112131415161718192021222324class Airplane &#123; //...&#125;class Boeing777 extends Airplane &#123; //... getCruisingAltitude() &#123; return getMaxAltitude() - getPassengerCount(); &#125;&#125;class AirForceOne extends Airplane &#123; //... getCruisingAltitude() &#123; return getMaxAltitude(); &#125;&#125;class Cessna extends Airplane &#123; //... getCruisingAltitude() &#123; return getMaxAltitude() - getFuelExpenditure(); &#125;&#125;回到目录避免类型判断(part 1)JS 是弱类型语言，这意味着函数可接受任意类型的参数。有时这会对你带来麻烦，你会对参数做一些类型判断。有许多方法可以避免这些情况。反例:1234567function travelToTexas(vehicle) &#123; if (vehicle instanceof Bicycle) &#123; vehicle.peddle(this.currentLocation, new Location('texas')); &#125; else if (vehicle instanceof Car) &#123; vehicle.drive(this.currentLocation, new Location('texas')); &#125;&#125;正例:123function travelToTexas(vehicle) &#123; vehicle.move(this.currentLocation, new Location('texas'));&#125;回到目录避免类型判断(part 2)如果需处理的数据为字符串，整型，数组等类型，无法使用多态并仍有必要对其进行类型检测时，可以考虑使用 TypeScript。反例:12345678function combine(val1, val2) &#123; if (typeof val1 == \"number\" &amp;&amp; typeof val2 == \"number\" || typeof val1 == \"string\" &amp;&amp; typeof val2 == \"string\") &#123; return val1 + val2; &#125; else &#123; throw new Error('Must be of type String or Number'); &#125;&#125;正例:123function combine(val1, val2) &#123; return val1 + val2;&#125;回到目录避免过度优化现代的浏览器在运行时会对代码自动进行优化。有时人为对代码进行优化可能是在浪费时间。这里可以找到许多真正需要优化的地方反例:1234567// 这里使用变量len是因为在老式浏览器中，// 直接使用正例中的方式会导致每次循环均重复计算list.length的值，// 而在现代浏览器中会自动完成优化，这一行为是没有必要的for (var i = 0, len = list.length; i &lt; len; i++) &#123; // ...&#125;正例:123for (var i = 0; i &lt; list.length; i++) &#123; // ...&#125;回到目录删除无效的代码不再被调用的代码应及时删除。反例:12345678910function oldRequestModule(url) &#123; // ...&#125;function newRequestModule(url) &#123; // ...&#125;var req = newRequestModule;inventoryTracker('apples', req, 'www.inventory-awesome.io');正例:123456function newRequestModule(url) &#123; // ...&#125;var req = newRequestModule;inventoryTracker('apples', req, 'www.inventory-awesome.io');回到目录对象和数据结构使用 getters 和 settersJS 没有接口或类型，因此实现这一模式是很困难的，因为我们并没有类似 public 和 private 的关键词。然而，使用 getters 和 setters 获取对象的数据远比直接使用点操作符具有优势。为什么呢？当需要对获取的对象属性执行额外操作时。执行 set 时可以增加规则对要变量的合法性进行判断。封装了内部逻辑。在存取时可以方便的增加日志和错误处理。继承该类时可以重载默认行为。从服务器获取数据时可以进行懒加载。反例:12345678910class BankAccount &#123; constructor() &#123; this.balance = 1000; &#125;&#125;let bankAccount = new BankAccount();// Buy shoes...bankAccount.balance = bankAccount.balance - 100;正例:1234567891011121314151617class BankAccount &#123; constructor() &#123; this.balance = 1000; &#125; // It doesn't have to be prefixed with `get` or `set` to be a getter/setter withdraw(amount) &#123; if (verifyAmountCanBeDeducted(amount)) &#123; this.balance -= amount; &#125; &#125;&#125;let bankAccount = new BankAccount();// Buy shoes...bankAccount.withdraw(100);回到目录让对象拥有私有成员可以通过闭包完成反例:12345678910111213var Employee = function(name) &#123; this.name = name;&#125;Employee.prototype.getName = function() &#123; return this.name;&#125;var employee = new Employee('John Doe');console.log('Employee name: ' + employee.getName()); // Employee name: John Doedelete employee.name;console.log('Employee name: ' + employee.getName()); // Employee name: undefined正例:1234567891011121314var Employee = (function() &#123; function Employee(name) &#123; this.getName = function() &#123; return name; &#125;; &#125; return Employee;&#125;());var employee = new Employee('John Doe');console.log('Employee name: ' + employee.getName()); // Employee name: John Doedelete employee.name;console.log('Employee name: ' + employee.getName()); // Employee name: John Doe回到目录类单一职责原则 (SRP)如《代码整洁之道》一书中所述，“修改一个类的理由不应该超过一个”。将多个功能塞进一个类的想法很诱人，但这将导致你的类无法达到概念上的内聚，并经常不得不进行修改。最小化对一个类需要修改的次数是非常有必要的。如果一个类具有太多太杂的功能，当你对其中一小部分进行修改时，将很难想象到这一修够对代码库中依赖该类的其他模块会带来什么样的影响。反例:123456789101112131415class UserSettings &#123; constructor(user) &#123; this.user = user; &#125; changeSettings(settings) &#123; if (this.verifyCredentials(user)) &#123; // ... &#125; &#125; verifyCredentials(user) &#123; // ... &#125;&#125;正例:1234567891011121314151617181920212223class UserAuth &#123; constructor(user) &#123; this.user = user; &#125; verifyCredentials() &#123; // ... &#125;&#125;class UserSettings &#123; constructor(user) &#123; this.user = user; this.auth = new UserAuth(user) &#125; changeSettings(settings) &#123; if (this.auth.verifyCredentials()) &#123; // ... &#125; &#125;&#125;回到目录开/闭原则 (OCP)“代码实体(类，模块，函数等)应该易于扩展，难于修改。”这一原则指的是我们应允许用户方便的扩展我们代码模块的功能，而不需要打开 js 文件源码手动对其进行修改。反例:123456789101112class AjaxRequester &#123; constructor() &#123; // What if we wanted another HTTP Method, like DELETE? We would have to // open this file up and modify this and put it in manually. this.HTTP_METHODS = ['POST', 'PUT', 'GET']; &#125; get(url) &#123; // ... &#125;&#125;正例:12345678910111213class AjaxRequester &#123; constructor() &#123; this.HTTP_METHODS = ['POST', 'PUT', 'GET']; &#125; get(url) &#123; // ... &#125; addHTTPMethod(method) &#123; this.HTTP_METHODS.push(method); &#125;&#125;回到目录利斯科夫替代原则 (LSP)“子类对象应该能够替换其超类对象被使用”。也就是说，如果有一个父类和一个子类，当采用子类替换父类时不应该产生错误的结果。反例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Rectangle &#123; constructor() &#123; this.width = 0; this.height = 0; &#125; setColor(color) &#123; // ... &#125; render(area) &#123; // ... &#125; setWidth(width) &#123; this.width = width; &#125; setHeight(height) &#123; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125;&#125;class Square extends Rectangle &#123; constructor() &#123; super(); &#125; setWidth(width) &#123; this.width = width; this.height = width; &#125; setHeight(height) &#123; this.width = height; this.height = height; &#125;&#125;function renderLargeRectangles(rectangles) &#123; rectangles.forEach((rectangle) =&gt; &#123; rectangle.setWidth(4); rectangle.setHeight(5); let area = rectangle.getArea(); // BAD: Will return 25 for Square. Should be 20. rectangle.render(area); &#125;)&#125;let rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles(rectangles);正例:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Shape &#123; constructor() &#123;&#125; setColor(color) &#123; // ... &#125; render(area) &#123; // ... &#125;&#125;class Rectangle extends Shape &#123; constructor() &#123; super(); this.width = 0; this.height = 0; &#125; setWidth(width) &#123; this.width = width; &#125; setHeight(height) &#123; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125;&#125;class Square extends Shape &#123; constructor() &#123; super(); this.length = 0; &#125; setLength(length) &#123; this.length = length; &#125; getArea() &#123; return this.length * this.length; &#125;&#125;function renderLargeShapes(shapes) &#123; shapes.forEach((shape) =&gt; &#123; switch (shape.constructor.name) &#123; case 'Square': shape.setLength(5); case 'Rectangle': shape.setWidth(4); shape.setHeight(5); &#125; let area = shape.getArea(); shape.render(area); &#125;)&#125;let shapes = [new Rectangle(), new Rectangle(), new Square()];renderLargeShapes(shapes);回到目录接口隔离原则 (ISP)“客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。”在 JS 中，当一个类需要许多参数设置才能生成一个对象时，或许大多时候不需要设置这么多的参数。此时减少对配置参数数量的需求是有益的。反例:123456789101112131415161718192021class DOMTraverser &#123; constructor(settings) &#123; this.settings = settings; this.setup(); &#125; setup() &#123; this.rootNode = this.settings.rootNode; this.animationModule.setup(); &#125; traverse() &#123; // ... &#125;&#125;let $ = new DOMTraverser(&#123; rootNode: document.getElementsByTagName('body'), animationModule: function() &#123;&#125; // Most of the time, we won't need to animate when traversing. // ...&#125;);正例:1234567891011121314151617181920212223242526272829class DOMTraverser &#123; constructor(settings) &#123; this.settings = settings; this.options = settings.options; this.setup(); &#125; setup() &#123; this.rootNode = this.settings.rootNode; this.setupOptions(); &#125; setupOptions() &#123; if (this.options.animationModule) &#123; // ... &#125; &#125; traverse() &#123; // ... &#125;&#125;let $ = new DOMTraverser(&#123; rootNode: document.getElementsByTagName('body'), options: &#123; animationModule: function() &#123;&#125; &#125;&#125;);回到目录依赖反转原则 (DIP)该原则有两个核心点：高层模块不应该依赖于低层模块。他们都应该依赖于抽象接口。抽象接口应该脱离具体实现，具体实现应该依赖于抽象接口。反例:12345678910111213141516171819202122232425262728class InventoryTracker &#123; constructor(items) &#123; this.items = items; // BAD: We have created a dependency on a specific request implementation. // We should just have requestItems depend on a request method: `request` this.requester = new InventoryRequester(); &#125; requestItems() &#123; this.items.forEach((item) =&gt; &#123; this.requester.requestItem(item); &#125;); &#125;&#125;class InventoryRequester &#123; constructor() &#123; this.REQ_METHODS = ['HTTP']; &#125; requestItem(item) &#123; // ... &#125;&#125;let inventoryTracker = new InventoryTracker(['apples', 'bananas']);inventoryTracker.requestItems();正例:12345678910111213141516171819202122232425262728293031323334353637class InventoryTracker &#123; constructor(items, requester) &#123; this.items = items; this.requester = requester; &#125; requestItems() &#123; this.items.forEach((item) =&gt; &#123; this.requester.requestItem(item); &#125;); &#125;&#125;class InventoryRequesterV1 &#123; constructor() &#123; this.REQ_METHODS = ['HTTP']; &#125; requestItem(item) &#123; // ... &#125;&#125;class InventoryRequesterV2 &#123; constructor() &#123; this.REQ_METHODS = ['WS']; &#125; requestItem(item) &#123; // ... &#125;&#125;// By constructing our dependencies externally and injecting them, we can easily// substitute our request module for a fancy new one that uses WebSockets.let inventoryTracker = new InventoryTracker(['apples', 'bananas'], new InventoryRequesterV2());inventoryTracker.requestItems();回到目录使用 ES6 的 classes 而不是 ES5 的 Function典型的 ES5 的类(function)在继承、构造和方法定义方面可读性较差。当需要继承时，优先选用 classes。但是，当在需要更大更复杂的对象时，最好优先选择更小的 function 而非 classes。反例:1234567891011121314151617181920212223242526272829303132333435var Animal = function(age) &#123; if (!(this instanceof Animal)) &#123; throw new Error(\"Instantiate Animal with `new`\"); &#125; this.age = age;&#125;;Animal.prototype.move = function() &#123;&#125;;var Mammal = function(age, furColor) &#123; if (!(this instanceof Mammal)) &#123; throw new Error(\"Instantiate Mammal with `new`\"); &#125; Animal.call(this, age); this.furColor = furColor;&#125;;Mammal.prototype = Object.create(Animal.prototype);Mammal.prototype.constructor = Mammal;Mammal.prototype.liveBirth = function() &#123;&#125;;var Human = function(age, furColor, languageSpoken) &#123; if (!(this instanceof Human)) &#123; throw new Error(\"Instantiate Human with `new`\"); &#125; Mammal.call(this, age, furColor); this.languageSpoken = languageSpoken;&#125;;Human.prototype = Object.create(Mammal.prototype);Human.prototype.constructor = Human;Human.prototype.speak = function() &#123;&#125;;正例:12345678910111213141516171819202122232425class Animal &#123; constructor(age) &#123; this.age = age; &#125; move() &#123;&#125;&#125;class Mammal extends Animal &#123; constructor(age, furColor) &#123; super(age); this.furColor = furColor; &#125; liveBirth() &#123;&#125;&#125;class Human extends Mammal &#123; constructor(age, furColor, languageSpoken) &#123; super(age, furColor); this.languageSpoken = languageSpoken; &#125; speak() &#123;&#125;&#125;回到目录使用方法链这里我们的理解与《代码整洁之道》的建议有些不同。有争论说方法链不够干净且违反了德米特法则，也许这是对的，但这种方法在 JS 及许多库(如 JQuery)中显得非常实用。因此，我认为在 JS 中使用方法链是非常合适的。在 class 的函数中返回 this，能够方便的将类需要执行的多个方法链接起来。反例:1234567891011121314151617181920212223242526272829class Car &#123; constructor() &#123; this.make = 'Honda'; this.model = 'Accord'; this.color = 'white'; &#125; setMake(make) &#123; this.name = name; &#125; setModel(model) &#123; this.model = model; &#125; setColor(color) &#123; this.color = color; &#125; save() &#123; console.log(this.make, this.model, this.color); &#125;&#125;let car = new Car();car.setColor('pink');car.setMake('Ford');car.setModel('F-150')car.save();正例:1234567891011121314151617181920212223242526272829303132333435class Car &#123; constructor() &#123; this.make = 'Honda'; this.model = 'Accord'; this.color = 'white'; &#125; setMake(make) &#123; this.name = name; // NOTE: Returning this for chaining return this; &#125; setModel(model) &#123; this.model = model; // NOTE: Returning this for chaining return this; &#125; setColor(color) &#123; this.color = color; // NOTE: Returning this for chaining return this; &#125; save() &#123; console.log(this.make, this.model, this.color); &#125;&#125;let car = new Car() .setColor('pink') .setMake('Ford') .setModel('F-150') .save();回到目录优先使用组合模式而非继承在著名的设计模式一书中提到，应多使用组合模式而非继承。这么做有许多优点，在想要使用继承前，多想想能否通过组合模式满足需求吧。那么，在什么时候继承具有更大的优势呢？这取决于你的具体需求，但大多情况下，可以遵守以下三点：继承关系表现为”是一个”而非”有一个”(如动物-&gt;人 和 用户-&gt;用户细节)可以复用基类的代码(“Human”可以看成是”All animal”的一种)希望当基类改变时所有派生类都受到影响(如修改”all animals”移动时的卡路里消耗量)反例:12345678910111213141516171819class Employee &#123; constructor(name, email) &#123; this.name = name; this.email = email; &#125; // ...&#125;// Bad because Employees \"have\" tax data. EmployeeTaxData is not a type of Employeeclass EmployeeTaxData extends Employee &#123; constructor(ssn, salary) &#123; super(); this.ssn = ssn; this.salary = salary; &#125; // ...&#125;正例:123456789101112131415161718192021class Employee &#123; constructor(name, email) &#123; this.name = name; this.email = email; &#125; setTaxData(ssn, salary) &#123; this.taxData = new EmployeeTaxData(ssn, salary); &#125; // ...&#125;class EmployeeTaxData &#123; constructor(ssn, salary) &#123; this.ssn = ssn; this.salary = salary; &#125; // ...&#125;回到目录测试一些好的覆盖工具。一些好的 JS 测试框架。单一的测试每个概念反例:12345678910111213141516171819const assert = require('assert');describe('MakeMomentJSGreatAgain', function() &#123; it('handles date boundaries', function() &#123; let date; date = new MakeMomentJSGreatAgain('1/1/2015'); date.addDays(30); date.shouldEqual('1/31/2015'); date = new MakeMomentJSGreatAgain('2/1/2016'); date.addDays(28); assert.equal('02/29/2016', date); date = new MakeMomentJSGreatAgain('2/1/2015'); date.addDays(28); assert.equal('03/01/2015', date); &#125;);&#125;);正例:123456789101112131415161718192021const assert = require('assert');describe('MakeMomentJSGreatAgain', function() &#123; it('handles 30-day months', function() &#123; let date = new MakeMomentJSGreatAgain('1/1/2015'); date.addDays(30); date.shouldEqual('1/31/2015'); &#125;); it('handles leap year', function() &#123; let date = new MakeMomentJSGreatAgain('2/1/2016'); date.addDays(28); assert.equal('02/29/2016', date); &#125;); it('handles non-leap year', function() &#123; let date = new MakeMomentJSGreatAgain('2/1/2015'); date.addDays(28); assert.equal('03/01/2015', date); &#125;);&#125;);回到目录并发用 Promises 替代回调回调不够整洁并会造成大量的嵌套。ES6 内嵌了 Promises，使用它吧。反例:1234567891011121314require('request').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin', function(err, response) &#123; if (err) &#123; console.error(err); &#125; else &#123; require('fs').writeFile('article.html', response.body, function(err) &#123; if (err) &#123; console.error(err); &#125; else &#123; console.log('File written'); &#125; &#125;) &#125;&#125;)正例:12345678910require('request-promise').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin') .then(function(response) &#123; return require('fs-promise').writeFile('article.html', response); &#125;) .then(function() &#123; console.log('File written'); &#125;) .catch(function(err) &#123; console.error(err); &#125;)回到目录Async/Await 是较 Promises 更好的选择Promises 是较回调而言更好的一种选择，但 ES7 中的 async 和 await 更胜过 Promises。在能使用 ES7 特性的情况下可以尽量使用他们替代 Promises。反例:12345678910require('request-promise').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin') .then(function(response) &#123; return require('fs-promise').writeFile('article.html', response); &#125;) .then(function() &#123; console.log('File written'); &#125;) .catch(function(err) &#123; console.error(err); &#125;)正例:123456789101112async function getCleanCodeArticle() &#123; try &#123; var request = await require('request-promise') var response = await request.get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin'); var fileHandle = await require('fs-promise'); await fileHandle.writeFile('article.html', response); console.log('File written'); &#125; catch(err) &#123; console.log(err); &#125;&#125;回到目录错误处理错误抛出是个好东西！这使得你能够成功定位运行状态中的程序产生错误的位置。别忘了捕获错误对捕获的错误不做任何处理是没有意义的。代码中 try/catch 的意味着你认为这里可能出现一些错误，你应该对这些可能的错误存在相应的处理方案。反例:12345try &#123; functionThatMightThrow();&#125; catch (error) &#123; console.log(error);&#125;正例:1234567891011try &#123; functionThatMightThrow();&#125; catch (error) &#123; // One option (more noisy than console.log): console.error(error); // Another option: notifyUserOfError(error); // Another option: reportErrorToService(error); // OR do all three!&#125;不要忽略被拒绝的 promises理由同 try/catch。反例:1234567getdata().then(data =&gt; &#123; functionThatMightThrow(data);&#125;).catch(error =&gt; &#123; console.log(error);&#125;);正例:12345678910111213getdata().then(data =&gt; &#123; functionThatMightThrow(data);&#125;).catch(error =&gt; &#123; // One option (more noisy than console.log): console.error(error); // Another option: notifyUserOfError(error); // Another option: reportErrorToService(error); // OR do all three!&#125;);回到目录格式化格式化是一件主观的事。如同这里的许多规则一样，这里并没有一定/立刻需要遵守的规则。可以在这里完成格式的自动化。大小写一致JS 是弱类型语言，合理的采用大小写可以告诉你关于变量/函数等的许多消息。这些规则是主观定义的，团队可以根据喜欢进行选择。重点在于无论选择何种风格，都需要注意保持一致性。反例:1234567891011var DAYS_IN_WEEK = 7;var daysInMonth = 30;var songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];var Artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];function eraseDatabase() &#123;&#125;function restore_database() &#123;&#125;class animal &#123;&#125;class Alpaca &#123;&#125;正例:1234567891011var DAYS_IN_WEEK = 7;var DAYS_IN_MONTH = 30;var songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];var artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];function eraseDatabase() &#123;&#125;function restoreDatabase() &#123;&#125;class Animal &#123;&#125;class Alpaca &#123;&#125;回到目录调用函数的函数和被调函数应放在较近的位置当函数间存在相互调用的情况时，应将两者置于较近的位置。理想情况下，应将调用其他函数的函数写在被调用函数的上方。反例:1234567891011121314151617181920212223242526272829303132333435class PerformanceReview &#123; constructor(employee) &#123; this.employee = employee; &#125; lookupPeers() &#123; return db.lookup(this.employee, 'peers'); &#125; lookupMananger() &#123; return db.lookup(this.employee, 'manager'); &#125; getPeerReviews() &#123; let peers = this.lookupPeers(); // ... &#125; perfReview() &#123; getPeerReviews(); getManagerReview(); getSelfReview(); &#125; getManagerReview() &#123; let manager = this.lookupManager(); &#125; getSelfReview() &#123; // ... &#125;&#125;let review = new PerformanceReview(user);review.perfReview();正例:1234567891011121314151617181920212223242526272829303132333435class PerformanceReview &#123; constructor(employee) &#123; this.employee = employee; &#125; perfReview() &#123; getPeerReviews(); getManagerReview(); getSelfReview(); &#125; getPeerReviews() &#123; let peers = this.lookupPeers(); // ... &#125; lookupPeers() &#123; return db.lookup(this.employee, 'peers'); &#125; getManagerReview() &#123; let manager = this.lookupManager(); &#125; lookupMananger() &#123; return db.lookup(this.employee, 'manager'); &#125; getSelfReview() &#123; // ... &#125;&#125;let review = new PerformanceReview(employee);review.perfReview();回到目录注释只对存在一定业务逻辑复杂性的代码进行注释注释并不是必须的，好的代码是能够让人一目了然，不用过多无谓的注释。反例:1234567891011121314151617function hashIt(data) &#123; // The hash var hash = 0; // Length of string var length = data.length; // Loop through every character in data for (var i = 0; i &lt; length; i++) &#123; // Get character code. var char = data.charCodeAt(i); // Make the hash hash = ((hash &lt;&lt; 5) - hash) + char; // Convert to 32-bit integer hash = hash &amp; hash; &#125;&#125;正例:12345678910111213function hashIt(data) &#123; var hash = 0; var length = data.length; for (var i = 0; i &lt; length; i++) &#123; var char = data.charCodeAt(i); hash = ((hash &lt;&lt; 5) - hash) + char; // Convert to 32-bit integer hash = hash &amp; hash; &#125;&#125;回到目录不要在代码库中遗留被注释掉的代码版本控制的存在是有原因的。让旧代码存在于你的 history 里吧。反例:1234doStuff();// doOtherStuff();// doSomeMoreStuff();// doSoMuchStuff();正例:1doStuff();回到目录不需要版本更新类型注释记住，我们可以使用版本控制。废代码、被注释的代码及用注释记录代码中的版本更新说明都是没有必要的。需要时可以使用 git log 获取历史版本。反例:123456789/** * 2016-12-20: Removed monads, didn't understand them (RM) * 2016-10-01: Improved using special monads (JP) * 2016-02-03: Removed type-checking (LI) * 2015-03-14: Added combine with type-checking (JR) */function combine(a, b) &#123; return a + b;&#125;正例:123function combine(a, b) &#123; return a + b;&#125;回到目录避免位置标记这些东西通常只能代码麻烦，采用适当的缩进就可以了。反例:1234567891011121314////////////////////////////////////////////////////////////////////////////////// Scope Model Instantiation////////////////////////////////////////////////////////////////////////////////let $scope.model = &#123; menu: 'foo', nav: 'bar'&#125;;////////////////////////////////////////////////////////////////////////////////// Action setup////////////////////////////////////////////////////////////////////////////////let actions = function() &#123; // ...&#125;正例:12345678let $scope.model = &#123; menu: 'foo', nav: 'bar'&#125;;let actions = function() &#123; // ...&#125;回到目录避免在源文件中写入法律评论将你的 LICENSE 文件置于源码目录树的根目录。反例:123456789101112131415161718192021222324252627/*The MIT License (MIT)Copyright (c) 2016 Ryan McDermottPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the \"Software\"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE*/function calculateBill() &#123; // ...&#125;正例:123function calculateBill() &#123; // ...&#125;回到目录","updated":"2020-01-21T09:13:30.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"}]},{"title":"2019 年大前端技术趋势分析","date":"2019-08-12T02:25:25.000Z","path":"2019/08/12/FrontEnd/frontend-tendency-2019/","text":"技术采用生命周期创新者（Innovators）：技术的冒险者，第一时间尝试新技术。早期采用者（Early Adopters）：技术早期采用者，具备一定探索精神，某个领域的意见领袖。早期大众（early majority）：技术早期大众使用者，深思熟虑者，往往采用相对成熟的技术。晚期大众（late majority）：技术的平民老百姓，跟随趋势采用当前主流的技术。落后者（laggards）：技术的落后者，长时间不更新技术栈，存在大量技术债。技术方向按照大前端技术架构图进行分层，大体分为：状态管理、UI 组件、小程序、跨平台、框架层、编程语言、工程化、监控、测试和服务端。内容来源 https://www.infoq.cn/article/uQjaf_dAHm6viAXsuxzI","updated":"2019-08-12T02:25:25.000Z","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://nnorland.github.io/categories/FrontEnd/"}],"tags":[]},{"title":"杨辉三角的JavaScript实现","date":"2019-07-22T09:16:17.000Z","path":"2019/07/22/Pascal-Triangle/","text":"杨辉三角，是二项式系数在三角形中的一种几何排列，中国南宋数学家杨辉1261年所著的《详解九章算法》一书中出现。 在欧洲，帕斯卡（1623—-1662）在1654年发现这一规律，所以这个表又叫做帕斯卡三角形。 帕斯卡的发现比杨辉要迟393年，比贾宪迟600年。杨辉三角给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。示例:123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]]12345678910111213141516171819202122/** * @param &#123;number&#125; numRows * @return &#123;number[][]&#125; */var generate = function(numRows) &#123; const result = []; for (let i = 0; i &lt; numRows; i ++) &#123; const subArr = []; for (let j = 0; j &lt;= i; j++) &#123; if (j &gt; 0 &amp;&amp; j &lt; i) &#123; subArr.push(result[i-1][j-1] + result[i-1][j]); &#125; else &#123; subArr.push(1); &#125; &#125; result.push(subArr); &#125; return result;&#125;;给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行示例：12输入: 3输出: [1,3,3,1]123456789101112131415161718192021222324/** * @param &#123;number&#125; rowIndex * @return &#123;number[]&#125; 杨辉三角正好是二次项的展开式,(1+x)的n次幂的系数,有通项公式C(n-1,m-1)=(n-1)!/[(m-1)!(n-m)!] 而研究每一项后,发现他们的规律,如 C(4,1)=C(4,0)*4/1,C(4,2)=C(4,1)*3/2, C(4,3)=C(4,2)*2/3,C(4,4)=C(4,3)*1/4: */var getRow = function (rowIndex) &#123; if (rowIndex === 0) &#123; return [1] &#125; else if (rowIndex === 1) &#123; return [1, 1] &#125; else &#123; let index = 1 let result = [1] for (let i = 0; i &lt; rowIndex; i++) &#123; index = index * (rowIndex - i) / (i + 1); result.push(index) &#125; return result &#125;&#125;;// console.log('getRow(3)', getRow(5))123456789101112131415/** * @param &#123;number&#125; rowIndex * @return &#123;number[]&#125; */var getRow = function(rowIndex) &#123; if (rowIndex &lt; 0) return [] if (rowIndex === 0) return [1] let preRow = getRow(rowIndex - 1) let result = [] for (let i = 0; i &lt;= rowIndex; i++) &#123; if (i === 0 || i === rowIndex) result[i] = 1; else result[i] = preRow[i - 1] + preRow[i] &#125; return result&#125;;","updated":"2019-07-22T09:16:17.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://nnorland.github.io/tags/LeetCode/"}]},{"title":"数据结构与算法JavaScript描述","date":"2019-06-11T07:22:02.000Z","path":"2019/06/11/JavaScript/the-data-structure/","text":"数组有几个操作是将数组作为一个整体进行的。首先，可以将一个数组赋给另外一个数组:12345var nums = [];for (var i = 0; i &lt; 10; ++i) &#123; nums[i] = i+1;&#125;var samenums = nums;但是，当把一个数组赋给另外一个数组时，只是为被赋值的数组增加了一个新的引用。当 你通过原引用修改了数组的值，另外一个引用也会感知到这个变化。下面的代码展示了这 种情况:123456var nums = [];for (var i = 0; i &lt; 100; ++i) &#123; nums[i] = i+1;&#125;var samenums = nums;nums[0] = 400; print(samenums[0]); // 显示 400这种行为被称为浅复制，新数组依然指向原来的数组。一个更好的方案是使用深复制，将 原数组中的每一个元素都复制一份到新数组中。可以写一个深复制函数来做这件事:12345function copy(arr1, arr2) &#123; for (var i &#x3D; 0; i &lt; arr1.length; ++i) &#123; arr2[i] &#x3D; arr1[i]; &#125;&#125;关于JavaScript的深浅拷贝，可参考【知乎】javascript中的深拷贝和浅拷贝？","updated":"2019-06-11T07:22:02.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"}]},{"title":"JavaScript设计模式","date":"2018-06-20T11:20:28.000Z","path":"2018/06/20/JavaScript/JavaScript-Design-patterns/","text":"设计模式的类别创建型设计模式简单工厂模式（Simple Factory）工厂方法模式（Factory Method）抽象工厂模式（Abstract Factory）创建者模式（Builder）原型模式（Prototype）单例模式（Singleton）结构型设计模式外观模式/门面模式（Facade门面模式）适配器模式（Adapter）代理模式（Proxy）装饰模式（Decorator）桥梁模式/桥接模式（Bridge）组合模式（Composite）享元模式（Flyweight）行为设计模式模板方法模式（Template Method）观察者模式（Observer）状态模式（State）策略模式（Strategy）职责链模式（Chain of Responsibility）命令模式（Command）访问者模式（Visitor）调停者模式（Mediator）备忘录模式（Memento）迭代器模式（Iterator）解释器模式（Interpreter）三者之间的区别和联系创建型模式提供生存环境，结构型模式提供生存理由，行为型模式提供如何生存。创建型模式为其他两种模式使用提供了环境。结构型模式侧重于接口的使用，它做的一切工作都是对象或是类之间的交互，提供一个门。行为型模式顾名思义，侧重于具体行为，所以概念中才会出现职责分配和算法通信等内容。设计原则开闭原则：对扩展开放，对修改关闭里氏转换原则： 子类继承父类，单独完全可以运行依赖倒转原则： 引用一个对象，如果这个对象有底层类型，直接引用底层类型接口隔离原则： 每一个接口应该是一种角色合成/聚合复用原则： 新的对象应使用一些已有的对象，使之成为新对象的一部分迪米特原则： 一个对象应对其他对象有尽可能少的了解","updated":"2018-06-20T11:20:28.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"}]},{"title":"PN532 + 树莓派读写NFC","date":"2017-09-23T05:10:43.000Z","path":"2017/09/23/杂记/nfc-raspberrypi-pn532/","text":"公司门禁丢了要150。卧槽,果断自己做几张,把原版供起来。首先需要PN532芯片,RC522试了下,只能读卡,不能写卡。树莓派的UART被蓝牙占用,尝试无果。用I2C接口成功。pn532参考网站:参考资料附录&amp;相关链接：A1.libnfc配置方法A2.libnfc安装教程A3.libnfc用户APIA4.libnfc主页A5.libnfc学习例程A6.Iteadstudio PN532 ModuleA7.Disable R-Pi/RASPBIAN serial console for using UART0A8.http://geek-workshop.com/thread-10042-1-1.html系统搭建系统为Respbian系统配置执行sudo raspi-config进行配置.选择Interface Options，启用SPI、I2C，禁用Serial选择Advanced Options，1-Expand Filesystem 扩展分区安装依赖autoconf、libusb-dev、libtool、libpcsclite-dev123sudo apt-get update sudo apt-get upgrade sudo apt-get install autoconf libusb-dev libtool libpcsclite-dev工具安装树莓派与PN532连接树莓派3接口图树莓派3GPIO图我用的I2C接口,接线方式如下。04 &lt;-&gt; VCC06 &lt;-&gt; GND03 &lt;-&gt; SDA05 &lt;-&gt; SCLlibnfc顾名思义，nfc库。官方github:https://github.com/nfc-tools/libnfc12345678wget https://github.com/nfc-tools/libnfc/releases/download/libnfc-1.7.1/libnfc-1.7.1.tar.bz2tar -jxvf libnfc-1.7.1.tar.bz2cd libnfc-1.7.1autoreconf -vis./configure --with-drivers=all --sysconfdir=/etc --prefix=/usrmakesudo make installsudo mkdir /etc/nfc用I2C方式连接,需要1sudo nano &#x2F;etc&#x2F;nfc&#x2F;nfc&#x2F;libnfc.conf填写device.connstring = pn532_i2c:/dev/i2c-1其他配置项默认,修改参照上面的libnfc配置如果我们使用UART接口直接和PN532在树莓派上连接，则可以1sudo cp contrib&#x2F;libnfc&#x2F;pn532_uart_on_rpi.conf.sample &#x2F;etc&#x2F;nfc&#x2F;devices.d&#x2F;pn532_uart_on_rpi.conf执行nfc-list命令,输出123➜ ~ nfc-listnfc-list uses libnfc 1.7.1NFC device: pn532_i2c:/dev/i2c-1 openedmfoc官方github：https://github.com/nfc-tools/mfoc123456git clone https://github.com/nfc-tools/mfoc.gitcd mfoc/autoreconf -vis./configuremakesudo make installmfoc用法如下1234567891011121314151617181920Usage: mfoc [-h] [-k key] [-f file] … [-P probnum] [-T tolerance] [-O output]h print this help and exitk try the specified key in addition to the default keys //指定keyf parses a file of keys to add in addition to the default keys //用文件为输入指定多个keyP number of probes per sector, instead of default of 20 //每个扇区测试密钥数目T nonce tolerance half-range, instead of default of 20 (i.e., 40 for the total range, in both directions)O file in which the card contents will be written (REQUIRED) //输出dump的文件D file in which partial card info will be written in case PRNG is not vulnerableExample: mfoc -O mycard.mfdExample: mfoc -k ffffeeeedddd -O mycard.mfdExample: mfoc -f keys.txt -O mycard.mfdExample: mfoc -P 50 -T 30 -O mycard.mfdThis is mfoc version 0.10.7.For more information, run: ‘man mfoc’.[mfoc -h]mfcuk官方github:https://github.com/nfc-tools/mfcuk123456git clone https://github.com/nfc-tools/mfcuk.gitcd mfcukautoreconf -vis./configuremakesudo make install用法,执行1mfcuk写卡直接使用nfc-mfclassic即可对Mifare classic系列卡片写入。主要有M1卡（S50）和4K卡（S70）。1nfc-mfclassic详细描述mfoc是用来破解IC卡密钥的，一般的门禁卡很可能用的是默认密钥，破解起来很快。把要复制的卡放到读卡器上，运行1mfoc -O target.dmp如果不成功，说明加密没有用默认秘钥，可以增加每个区块的爆破次数1mfoc -P 500 -O target.dmp如果顺利你会看到所有block的信息都被dump出来。M1卡有16个sector，每个sector有4个block，所以一共是64个block。然后把一张新卡放上读卡器，也dump一次1mfoc -O blank.dmp接下来就可以写卡了1nfc-mfclassic W B target.dmp blank.dmp写完之后可以把新卡再dump出来，与原始卡比较一下1234mfoc -O new.dmphexdump -vC target.dmp &gt; target.hexhexdump -vC new.dmp &gt; new.hexdiff target.hex new.hex如果diff没有显示任何结果，恭喜，卡片已经100%复制成功，甚至不用去刷卡验证就知道可以了。","updated":"2017-09-23T05:10:43.000Z","categories":[{"name":"杂记","slug":"杂记","permalink":"https://nnorland.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"raspberrypi","slug":"raspberrypi","permalink":"https://nnorland.github.io/tags/raspberrypi/"},{"name":"nfc","slug":"nfc","permalink":"https://nnorland.github.io/tags/nfc/"}]},{"title":"ios禁用非交互的audio.play()方法","date":"2017-01-04T07:30:52.000Z","path":"2017/01/04/JavaScript/ios-audio-play/","text":"参考文献apple开发者中心谷歌有关audio的说明:User Control of Downloads Over Cellular Networks12345In Safari on iOS (for all devices, including iPad), where the user may be on a cellular network and be charged per data unit, preload and autoplay are disabled. No data is loaded until the user initiates it. This means the JavaScript play() and load() methods are also inactive until the user initiates playback, unless the play() or load() method is triggered by user action. In other words, a user-initiated Play button works, but an onLoad&#x3D;&quot;play()&quot; event does not. This plays the movie: &#96;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;Play&quot; onclick&#x3D;&quot;document.myMovie.play()&quot;&gt;&#96; This does nothing on iOS: &#96;&lt;body onload&#x3D;&quot;document.myMovie.play()&quot;&gt;&#96;用我学了长达12年的英语翻译一下“就是不可以啦，需要用户主动去触发才行的啦”。好了，我能做的就是这么多了，其实我还手动测试了一下其他hack方法，最后也以失败告终，直接解决办法就是绑定一个触摸事件给最上层容器上，用户肯定要触摸滚动之类的啊，这样不得不就触发了。最近遇到语音连续播放的问题,iOS禁用了非交互的audio.play()方法,之前采用的方法,模拟点击,各种hack,都没有效果.无奈放弃找到一种,动态src的方式来操作.事例代码如下.有待填坑12345678910111213141516171819202122232425262728window.onload = function() &#123; var arr = [ \"http://aliyun.mochi.shufawu.com/weixin-course/201611251845/207631360020730506.mp3\", \"http://aliyun.mochi.shufawu.com/weixin-course/201611251845/4479743430150737799.mp3\", \"http://aliyun.mochi.shufawu.com/weixin-course/201611241843/7952956551407820401.mp3\" ]; var myAudio = new Audio(); var ua = navigator.userAgent.toLowerCase(); if (/iphone|ipad|ipod/.test(ua)) &#123; alert(\"iphone\"); &#125; else &#123; alert('other') &#125; myAudio.preload = true; myAudio.controls = true; myAudio.src = arr.reverse().pop(); myAudio.addEventListener('ended', playEndedHandler, false); myAudio.play(); document.getElementById(\"audioBox\").appendChild(myAudio); myAudio.loop = false; myAudio.controls = true; function playEndedHandler() &#123; myAudio.src = arr.reverse().pop(); myAudio.play(); !arr.length &amp;&amp; myAudio.removeEventListener('ended', playEndedHandler, false); &#125;&#125;12345678910111213141516171819function startPlayback() &#123; return document.querySelector('#music').play();&#125;ChromeSamples.log('Attempting to play automatically...');startPlayback().then(function() &#123; ChromeSamples.log('The play() Promise fulfilled! Rock on!');&#125;).catch(function(error) &#123; ChromeSamples.log('The play() Promise rejected!'); ChromeSamples.log('Use the Play button instead.'); ChromeSamples.log(error); var playButton = document.querySelector('#play'); // The user interaction requirement is met if // playback is triggered via a click event. playButton.addEventListener('click', startPlayback); playButton.hidden = false;&#125;);","updated":"2017-01-04T07:30:52.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"},{"name":"IOS","slug":"IOS","permalink":"https://nnorland.github.io/tags/IOS/"}]},{"title":"css3混合模式","date":"2016-11-30T03:52:56.000Z","path":"2016/11/30/FrontEnd/css3-mix-blend-mode/","text":"工作中,遇到这样一个问题:我们可爱的设计师问我,能不能实现下面这个图的效果右边上面的二维码是从微信保存下来的二维码,左边是预期实现的效果,这里,图片采用了一中PS的混合模式:正片叠底。我看到的第一反应:我靠,这图片是白底的,让图片改变背景色?虽然出于前端和设计师之间的深厚友谊,本不应该在没有百度的情况下说没有办法实现的,但这个情况下我还是当机立断:这咋弄,没法实现。不过,遇到问题习惯性的问问百度,我就百度了一下,设计师所说的正片叠底。百度出的结果大跌眼镜,CSS还真的有这个属性。这就是CSS的mix-blend-mode(混合模式)属性。这个属性的作用就是让元素内容和这个元素的背景以及下面的元素发生“混合”。其支持的值还很多:1234567891011121314151617181920mix-blend-mode: normal; &#x2F;&#x2F;正常mix-blend-mode: multiply; &#x2F;&#x2F;正片叠底mix-blend-mode: screen; &#x2F;&#x2F;滤色mix-blend-mode: overlay; &#x2F;&#x2F;叠加mix-blend-mode: darken; &#x2F;&#x2F;变暗mix-blend-mode: lighten; &#x2F;&#x2F;变亮mix-blend-mode: color-dodge; &#x2F;&#x2F;颜色减淡mix-blend-mode: color-burn; &#x2F;&#x2F;颜色加深mix-blend-mode: hard-light; &#x2F;&#x2F;强光mix-blend-mode: soft-light; &#x2F;&#x2F;柔光mix-blend-mode: difference; &#x2F;&#x2F;差值mix-blend-mode: exclusion; &#x2F;&#x2F;排除mix-blend-mode: hue; &#x2F;&#x2F;色相mix-blend-mode: saturation; &#x2F;&#x2F;饱和度mix-blend-mode: color; &#x2F;&#x2F;颜色mix-blend-mode: luminosity; &#x2F;&#x2F;亮度mix-blend-mode: initial; &#x2F;&#x2F;初始mix-blend-mode: inherit; &#x2F;&#x2F;继承mix-blend-mode: unset; &#x2F;&#x2F;复原EXAMPLEGiven the following sample markup:123&lt;body&gt; &lt;img src=\"ducky.png\"/&gt;&lt;/body&gt;And the following style rule:1body &#123; background-color: green; &#125;… will produce the following result:If we change the style rule to include blending:12body &#123; background-color: green; &#125;img &#123; mix-blend-mode: multiply; &#125;… the output will be the image blending with the green background of theelement.不过目前兼容性还一般,万恶的IE全家,截止到写这篇文章的时候,兼容性是这样的Can I Use css-mixblendmode? Data on support for the css-mixblendmode feature across the major browsers from caniuse.com.一片飘红有没有?包括edge。看来还是谨慎使用吧。","updated":"2016-11-30T03:52:56.000Z","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://nnorland.github.io/categories/FrontEnd/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://nnorland.github.io/tags/CSS/"}]},{"title":"理解JavaScript函数参数","date":"2016-11-25T09:23:50.000Z","path":"2016/11/25/JavaScript/ECMAScript-function-arguments/","text":"ECMAScript函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。其实，arguments对象只是与数组类似（它并不是Array的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是arguments[0]，第二个元素是argumetns[1]，以此类推），使用length属性来确定传递进来多少个参数。不显式地使用命名参数：123function sayHi() &#123; alert(\"Hello \" + arguments[0] + \",\" + arguments[1]);&#125;ECMAScript函数的一个重要特点：命名的参数只提供便利，但不是必需的。另外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。但在ECMAScript中，没有这些条条框框，解析器不会验证命名参数。通过访问arguments对象的length属性可以获知有多少个参数传递给了函数。下面这个函数会在每次被调用时，输出传入其中的参数个数：1234567function howManyArgs() &#123; alert(arguments.length);&#125;howManyArgs(\"string\", 45); //2howManyArgs(); //0howManyArgs(12); //1执行以上代码会依次出现3个警告框，分别显示2、0和1。由此可见，开发人员可以利用这一点让函数能够接收任意个参数并分别实现适当的功能。请看下面的例子：12345678910function doAdd() &#123; if(arguments.length == 1) &#123; alert(arguments[0] + 10); &#125; else if (arguments.length == 2) &#123; alert(arguments[0] + arguments[1]); &#125;&#125;doAdd(10); //20doAdd(30, 20); //50函数doAdd()会在只有一个参数的情况下给该参数加上10；如果是两个参数，则将那个参数简单相加并返回结果。因此，doAdd(10)会返回20，而doAdd(30,20)则返回50。虽然这个特性算不上完美的重载，但也足够弥补ECMAScript的这一缺憾了。由于不存在函数签名的特性，ECMAScript函数不能重载另一个与参数相关的重要方面，就是arguments对象可以与命名参数一起使用，如下面的例子所示：1234567function doAdd(num1, num2) &#123; if(arguments.length == 1) &#123; alert(num1 + 10); &#125; else if (arguments.length == 2) &#123; alert(arguments[0] + num2); &#125;&#125;在重写后的这个doAdd()函数中，两个命名参数都与arguments对象一起使用。由于num1的值与arguments[0]的值相同，因此它们可以互换使用（当然，num2和arguments[1]也是如此）。关于arguments的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。例如：1234function doAdd(num1, num2) &#123; arguments[1] = 10; alert(arguments[0] + num2);&#125;每次执行这个doAdd()函数都会重写第二个参数，将第二个参数的值修改为10。因为arguments对象中的值会自动反映到对应的命名参数，所以修改arguments[1]，也就修改了num2，结果它们的值都会变成10。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。但这种影响是单向的：修改命名参数不会改变arguments中对应的值。另外还要记住，如果只传入了一个参数，那么为arguments[1]设置的值不会反应到命名参数中。这是因为arguments对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。关于参数还要记住最后一点：没有传递值的命名参数将自动被赋予undefined值。这就跟定义了变量但又没有初始化一样。例如，如果只给doAdd()函数传递了一个参数，则num2中就会保存undefined值。严格模式对如何使用argumetns对象做出了一些限制。首先，像前面例子中那样的赋值会变得无效。也就是说，即使把arguments[1]设置为10，num2的值仍然还是undefined。其次，重写arguments的值会导致语法错误（代码将不会执行）。ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。","updated":"2016-11-25T09:23:50.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"}]},{"title":"CSS揭秘读书笔记","date":"2016-11-22T08:38:56.000Z","path":"2016/11/22/FrontEnd/css-secrets/","text":"前言一项规范如果要推进到最终阶段，其中的每项特 性都必须具备两个独立的实现和全面的测试。原先的那种方式已经玩不转 了。因此，WC3决定跨出一步，将 CSS 打散到多个不同的规范(模块)中，每个模块都可以独立更新版本。这其中，那些延续CSS 2.1已有特性的模块 会升级到 3 这个版本号。比如:CSS 语法(http://w3.org/TR/css-syntax-3)CSS 层叠与继承(http://w3.org/TR/css-cascade-3)CSS 颜色(http://w3.org/TR/css3-color)选择符(http://w3.org/TR/selectors)CSS 背景与边框(http://w3.org/TR/css3-background)CSS 值与单位(http://w3.org/TR/css-values-3)CSS 文本排版(http://w3.org/TR/css-text-3)CSS 文本装饰效果(http://w3.org/TR/css-text-decor-3)CSS 字体(http://w3.org/TR/css3-fonts)CSS 基本 UI 特性(http://w3.org/TR/css3-ui)如果某个模块是前所未有的新概念，那它的版本号将从 1 开始。 比如下面这些:CSS 变形(http://w3.org/TR/css-transforms-1)图像混合效果(http://w3.org/TR/compositing-1)滤镜效果(http://w3.org/TR/filter-effects-1)CSS 遮罩(http://w3.org/TR/css-masking-1)CSS 伸缩盒布局(http://w3.org/TR/css-flexbox-1)CSS 网格布局(http://w3.org/TR/css-grid-1)尽管“CSS3”这个名词非常流行，但它实际上并没有在任何规范中定义过。真正的情况是，绝大多编辑在提到这个词时，指的是一个非正式的集合，它包括 CSS 规范第三 版(Level 3)再加上一些版本号还是1的新规范。现在CSS有很多实验性特性,而且部分特性已经正式发布使用.作为一名初级前端工程师,写页面-模板工程师职责-还是目前的主要本职工作,所以最近读了一本关于CSS的书籍.作为一门大热的编程语言,市面上新出版的关于JavaScript的书很多,但是,关于CSS的新书几乎没有,基本都是好几年前的,加上工作中经常发现没有用过,但很巧妙的CSS语法,感觉有必要再认真学一下关于CSS的知识了.这本书就在这时候出现了.从CSS魔法的博客得知,魔法哥刚好翻译完了一本新的CSS书籍,便找来读了读.读起来感觉很有意思.读书笔记和内容记录第一部分1. 合理简写有时候，代码易维护和代码量少不可兼得。来看看下面的代码片断，我们要为一个元素添加一道10px 宽的边框，但左侧不加边框。1border-width: 10px 10px 10px 0;只要这一条声明就可以搞定了，但如果日后要改动边框的宽度，你需要 同时改三个地方。如果把它拆成两条声明的话，改起来就容易多了，而且可 读性或许更好一些:12border-width: 10px; border-left-width: 0;又比如,123background: url(tr.png) no-repeat top right &#x2F; 2em 2em, url(br.png) no-repeat bottom right &#x2F; 2em 2em, url(bl.png) no-repeat bottom left &#x2F; 2em 2em;请注意 background-size 和 background-repeat 的值被重复了三遍，尽管每层背景的这两个值确实是相同的。其实我们可以从 CSS 的“列表扩散规则”那里得到好处。它的意思是说，如果只为某个属性提供一个值，那 它就会扩散并应用到列表中的每一项。因此，我们可以把这些重复的值从简写属性中抽出来写成一个展开式属性:12345background: url(tr.png) top right, url(br.png) bottom right, url(bl.png) bottom left; background-size: 2em 2em;background-repeat: no-repeat;2. currentColor在 CSS 颜色(第三版)(http://w3.org/TR/css3-color)规范中增加了一个特殊的颜色关键字 currentColor，它是从 SVG 那里借鉴来的。这个关键字并没有绑定到一个固定的颜色值，而是一直被解析为 color。实际上，这个特性让它成为了 CSS 中有史以来的第一个变量。3. 视觉错觉字母的形状在两端都比较整齐，而顶部和底部则往往参差不齐，从而导致你的眼睛把这些参差不齐的空缺部分感知为多出来的内边距。因此，如果我们希望四边的内边距看起来是基本一致的，就需要减少顶部和底部的内边距。如下图,图一 边距均相等,图二并不相等,但是图二在视觉上才是相等的。【图1】【图2】背景与边框1.多重边框box-shadow 方案box-shadow 的好处在于，它支持逗号分隔语法，我们 可以创建任意数量的投影。123background: yellowgreen; box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink, 0 2px 5px 15px rgba(0,0,0,.6);效果如图:需要注意的是，box-shadow 是层层叠加的，第一层投影位于最顶 层，依次类推。因此，你需要按此规律调整扩张半径outline 方案123background: yellowgreen; border: 10px solid #655; outline: 5px solid deeppink;描边的另一个好处在于，你可以通过 outline-offset 属性来控制它跟元素边缘之间的间距，这个属性甚至可以接受负值。这对于某些效果来说非常有用。举个例子，下图就实现了简单的缝边效果。只适合两层边框边框不一定会贴合 border-radius 属性产生的圆角，因此如果元素是圆角的，它的描边可能还是直角的。请注意，这种行 为被 CSS 工作组认为是一个 bug，因此未来可能会改为贴合 border- radius 圆角。CSS规范中,描边可以不是矩形,使用此方案最好做好不同浏览器的测试。2. calc() 方案1background-position: calc(100% - 20px) calc(100% - 10px);3.边框内圆角上面说过,使用outline绘制双重边框,圆角元素可能描边还是直角。解决办法1234background: tan; border-radius: .8em; padding: 1em;box-shadow: 0 0 0 .6em #655; outline: .6em solid #655;box-shadow + outline,两者叠加。实现效果如图但是这样,描边是直角,但是box-shadow实际上是圆角的,我们需要调整outline的扩张半径,刚好填充圆角空隙。此处用到勾股定理(小学知识还能用上)。如图为了让这个效果得以达成，扩张半径需要比描边的宽度值小，但它同时又要比 ( 2 −1)r 大注意:如果描边的宽度比 ( 2 −1)r 小， 那我们是不可能用这个方法达成该效果的。","updated":"2016-11-22T08:38:56.000Z","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://nnorland.github.io/categories/FrontEnd/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://nnorland.github.io/tags/CSS/"}]},{"title":"几个优秀的图片占位网站","date":"2016-11-18T10:02:42.000Z","path":"2016/11/18/FrontEnd/image-placeholder/","text":"在开发网站时，通常需要填充一些图片来预览页面效果，如果没有合适的素材，这时我们就需要占位图片，通过 URL 定制形如 sitename.com/width/height 的地址就可以得到一个随机的占位图片。下面就来细数10个优秀的占位图片生成网站。Placehold.itA quick and simple image placeholder service.123&lt;img src=\"http://placehold.it/350x200\" /&gt;&lt;img src=\"http://placehold.it/300/09f/fff.png\" /&gt;&lt;img src=\"http://placehold.it/300&amp;text=placehold.it+rocks!\" /&gt;可定制：图片格式、背景颜色、文本、文本颜色、图像尺寸lorempixelPlaceholder Images for every case.Webdesign or Print. Just put a custom url in your html and you receive a proper placeholder picture123456http://lorempixel.com/400/200to get a random picture of 400 x 200 pixelshttp://lorempixel.com/g/400/200to get a random gray picture of 400 x 200 pixelshttp://lorempixel.com/400/200/sportsto get a random picture of the sports categoryhttp://lorempixel.com/400/200/sports/1to get picture no. 1/10 from the sports categoryhttp://lorempixel.com/400/200/sports/Dummy-Text...with a custom text on the random Picturehttp://lorempixel.com/400/200/sports/1/Dummy-Text...with a custom text on the selected Picture可定制：图像分类、文本、图像尺寸、灰度图片Fake images please?You just have to put your image size after our URL.Only the first parameter is mandatory. There are options too,you can pass a text, or change some colors.Colors must be hexadecimal,the first one is the background color.You can add the alpha value of the color with a comma, (hex,a).The text can be passed with the text GET variable.Here are some examples you can look at:1234567&lt;img src=\"http://fakeimg.pl/300/\"&gt;&lt;img src=\"http://fakeimg.pl/250x100/\"&gt;&lt;img src=\"http://fakeimg.pl/250x100/ff0000/\"&gt;&lt;img src=\"http://fakeimg.pl/350x200/ff0000/000\"&gt;&lt;img src=\"http://fakeimg.pl/350x200/ff0000,128/000,255\"&gt;&lt;img src=\"http://fakeimg.pl/350x200/?text=Hello\"&gt;&lt;img src=\"http://fakeimg.pl/350x200/?text=World&amp;font=lobster\"&gt;可定制：背景颜色、文本、文本颜色、图像尺寸、文本字体{placekitten}A quick and simple service for getting pictures ofkittens for use as placeholders in your designs or code.Just put your image size (width &amp; height) after our URLand you’ll get a placeholder.1234567891011121314Like this: http:&#x2F;&#x2F;placekitten.com&#x2F;200&#x2F;300or: http:&#x2F;&#x2F;placekitten.com&#x2F;g&#x2F;200&#x2F;300&#96;&#96;&#96; ![](http:&#x2F;&#x2F;placekitten.com&#x2F;g&#x2F;200&#x2F;300) 可定制：图像尺寸、灰度图片# [hhhhold!](http:&#x2F;&#x2F;hhhhold.com)Never understimate the insanity of user-generated content in your projects again.&#96;&#96;&#96;html&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;hhhhold.com&#x2F;350x200&quot; &#x2F;&gt;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;hhhhold.com&#x2F;m&#x2F;w&#x2F;b&quot; &#x2F;&gt;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;hhhold.com&#x2F;350x200&#x2F;png&quot; &#x2F;&gt;可定制：图像尺寸、随机尺寸、图片格式还有 The Random Image Generator,占位图 等等参考: http://www.uedsc.com/the-top-10-placeholder-image-services.html","updated":"2023-01-15T02:37:22.878Z","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://nnorland.github.io/categories/FrontEnd/"}],"tags":[{"name":"html","slug":"html","permalink":"https://nnorland.github.io/tags/html/"}]},{"title":"各种定律","date":"2016-10-31T05:41:32.000Z","path":"2016/10/31/all-kinds-of-laws/","text":"各种定律包括计算机领域,心理学等,都有很多很有意思的定律,这是遇到的一些定律,这里做一个记录墨菲定律“墨菲定律”是一种心理学效应，是由爱德华·墨菲（Edward A. Murphy）提出的。主要内容：任何事都没有表面看起来那么简单；所有的事都会比你预计的时间长；会出错的事总会出错；如果你担心某种情况发生，那么它就更有可能发生。墨菲定律的原句是这样的：如果有两种或两种以上的方式去做某件事情，而其中一种选择方式将导致灾难，则必定有人会做出这种选择。这句话迅速流传。墨菲定律是其作出的著名论断，亦称墨菲定律、墨菲定理，是西方世界常用的俚语。墨菲定律主要内容是：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。吸引力法则吸引定律，又称“吸引力法则”，指思想集中在某一领域的时候，跟这个领域相关的人、事、物就会被他吸引而来。吸引力法则也是一种心理学理论,其观点和墨菲定律有相似之处.摩尔定律摩尔定律是由英特尔（Intel）创始人之一戈登·摩尔（Gordon Moore）提出来的。 其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。阿特伍德定律Jeff Atwood在2007年的一篇博客文章中提出，“any application that can be written in JavaScript, will eventually be written in JavaScript”，意即“任何可以用JavaScript来写的应用，最终都将用JavaScript来写”。这就是所谓的阿特伍德定律（Atwood’s Law）。相关链接the principle of least powerall programming is web programming中文译文 所有编程皆为Web编程深入理解Atwood定律虽然本身身为一名web程序员,很期待这样的发展,但是,本身对于此定律,还是要有批判性的阅读,当做一篇很有意思的文章来阅读吧,仅此而已.大牛的一些名言听起来似是而非，不经过细致的阅读是很难真正理解其逻辑的，而且即使细致阅读了，可能因为思维方式和实践机会的限制，完全理解其精髓也是很难的，在这样低的基础上再想有什么创新就更难了。这大概也是中关村的挨踢水平远远低于硅谷，中国的互联网公司大都只能依赖山寨的方式生存的原因吧。","updated":"2023-01-15T02:37:22.882Z","categories":[],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://nnorland.github.io/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"angular-controller-directive-factory","date":"2016-10-24T03:06:50.000Z","path":"2016/10/24/JavaScript/angular-controller-directive-factory/","text":"要了解使用方式的话，先要简（shen）单（ru）理解 Controller、Directive 和 Factory 分别是什么。文章主旨：Angular 2 就是 Angular 1.x 最佳实践的延伸，所以了解 Angular 2 中的做法，就可以了解 Angular 1.x 中应该怎么做。。作者：Trotyl Yu链接：https://www.zhihu.com/question/27836513/answer/76686560来源：知乎著作权归作者所有，转载请联系作者获得授权。1. ControllerController 虽然叫 Controller，但远没有后端框架中的 Controller 那么复杂的作用，Angular 1.x 中的 Controller，说得不好听一下，就仅仅是一个初始化器（Initializer），进行相关的数据绑定（包括字段和方法）而已，一般的初学者用法如下：12345678// Angular 1.x with $scope in ES5myApp.controller('myController', ['$scope', 'itemService', function($scope, itemService) &#123; $scope.currentItem = itemService.current(); $scope.items = itemService.all(); $scope.add = function(item) &#123; itemService.add(item); &#125;;&#125;]);可以看到，上面的代码中，Controller 干的事情仅仅就是把相应的数据或者方法绑定到 ViewModel 中。随着 Angular 1.2 中 Controller As 语法的到来，就不再需要 $scope 了：12345678// Angular 1.x with 'controller as' in ES5myApp.controller('myController', ['itemService', function(itemService) &#123; this.currentItem = itemService.current(); this.items = itemService.all(); this.add = function(item) &#123; itemService.add(item); &#125;;&#125;]);这样，就可以抛弃 $scope 了（其实事件传递还是有可能用到）。看到 this 之后，我们不妨思考一下，这些属性到底是对象独有的还是类（严格地说JavaScript中叫原型）共有的呢？通常都是后者，即只要是这个 Controller，都要有这些属性。这样，我们就可以考虑，把不变性的内容（比如基本上所有的方法）作为原型的属性而非对象的属性：1234567891011// Angular 1.x with 'controller as' in ES5myApp.controller('myController', ['itemService', ItemController]);function ItemController(itemService) &#123; this.currentItem = itemService.current(); this.items = itemService.all();&#125;ItemController.protoype.add = function(item) &#123; itemService.add(item);&#125;;这样就避免了把一坨方法绑定也挤到 Controller 里，也可以更清晰的看出 Controller 的初始化作用。（this 会顺着原型链查找的，但是可能很多用 Angular 的人并没有清晰的看到 Angular 仍然是普通的 JavaScript。）然后，随着 ES6 的流行，我们可以很轻松的转换成 ES6 的版本：12345678910111213// Angular 1.x with 'controller as' in ES6myApp.controller('myController', ['itemService', ItemController]);class ItemController &#123; constructor(itemService) &#123; this.itemService = itemService; this.currentItem = itemService.current(); this.items = itemService.all(); &#125; add(item) &#123; this.itemService.add(item); &#125;&#125;所以，因为 Controller 的作用就只是初始化，在有了类（class）的情况下，就完全可以被同化到 class 的 constructor 里面了。如果开发人员喜欢静态类型的话，还可以使用 TypeScript，也就相当于在 ES6 的基础上增加了一个静态的类型系统：1234567891011121314// Angular 1.x with 'controller as' in TypeScriptmyApp.controller('myController', ['itemService', ItemController]);class ItemController &#123; private currentItem: Item; private items: Item[]; constructor(private itemService: ItemService) &#123; this.currentItem = itemService.current(); this.items = itemService.all(); &#125; add(item: Item): void &#123; this.itemService.add(item); &#125;&#125;其中，用到了 TypeScript 的一个语法糖，即在构造函数的参数名前加上可访问性修饰符（private、public）可以直接添加为实例的属性。最后，我们就可以很容易理解 Angular 2 中的写法了：123456789101112131415// Angular 2 in TypeScript@Component(&#123; ...&#125;)class ItemController &#123; private currentItem: Item; private items: Item[]; constructor(private itemService: ItemService) &#123; this.currentItem = itemService.current(); this.items = itemService.all(); &#125; add(item: Item): void &#123; this.itemService.add(item); &#125;&#125;由于 TypeScript 提供了 Metadata 支持，Angular 2 可以直接按类型注入（当然也依然可以使用按名注入，如果有特殊需求的话），不需要再手动键入依赖名称了。综上所述，Controller 唯一的作用就是初始化，除了从外部到 ViewModel 的简单赋值（或极其简单的运算外），其他所有过程都不应该出现在 Controller 中。2. DirectiveAngular 1.x 中的一个奇葩问题就是把所有自定义的 HTML 扩展都叫做 Directive，引起了很多误会。Angular 中的 Directive 按用途分为三种：Component DirectiveAttribute DirectiveStructural DirectiveStructural Directive 是最特殊的，相当于一般 MVC 框架中 Template 的关键字，作用是影响 HTML 的文档结构而非特定元素，比如 ngRepeat、ngInclude、ngIf、ngSwtich 等。另外两种的话就很好分了，不出意外的话 restrict: ‘E’ 就是 Component Directive，restrict: ‘A’ 就是 Attribute Directive，前者作为一个独立元素（或者说组件）存在，比如 ngForm，后者影响现有元素/组件的某些效果，比如 ngClass、ngModel、ngSrc、ngStyle、ngClick 等。（在 Angular 2 中由于引入了通用的属性绑定和事件绑定机制如 [class.someKey]=”someValue”、[style.someKey]=”someValue”、[src]=”someValue”、(click)=”someMethodCall()”，所以对原有属性的封装和对原生事件的封装的 Attribute Directive 都不需要了）Angular 1.x 中，controller 既可以作为 Component Directive 的属性也可以作为 Attribute Directive 的属性（比如 ngController、ngView），但是由于由 ngController 的存在，近乎于可以创造独立于 Directive 的 Controller。Angular 2 中废弃了 ngController 这个存在，所有需要用到 Controller （或者说 Constructor）的地方都需要自己定义相应的 Directive。综上所述（虽然好像并没有怎么述），Angular 的哲学理念就是保证 View 层尽可能的使用声明式语法（而非命令式语法），一切初始化相关的东西都放在 Controller 中（慎用 ngInit），所有需要用到 Controller 的地方都封装成自己的 Directive。3. Factory？如果说的是 Provider、Factory、Service、Value、Constant 的总称的话，一般来说并没有 Factory 的叫法，要么叫 Service（官方早期是这么叫的，但是会有 a Service is a Service 这种跨层次重名情况），或者叫 Provider（除 Constant 外本质上都是 Provider，Value 和 Service 是调用的 Factory，Factory 是调用的 Provider），或者高雅一点叫 Dependency。这里暂时叫一下 Provider，如果不习惯的话，脑补成别的名词就好。。其实如果按本文这种顺序的话，用下排除法就知道什么时候该用 Provider 了，所有没有在上面两者的职责内的情况，包括但不仅限于网络、存储等其他一切与展示逻辑无关的内容。至于这几个东东内部的区别，The Provider（不是泛指）的话具有可配置性，可以在程序运行前进行相应的设定；Factory 和 Service 除了写法上没有什么区别，喜欢用什么用什么，不一定要按它的名字来；Value 和 Constant 为单个对象依赖，Constant 可以在 Provider 的配置阶段使用，其他都不能。Angular 2 把上面这些东西的名词叫法合并了，虽然实际上并没有什么功能上的改变。（不过，依赖注入的机制倒是改了不少。）综上所述，所有与展示逻辑（或者说交互逻辑）无关的部分都应该写成 Provider（广义的）。","updated":"2023-01-15T02:37:22.880Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"},{"name":"angular","slug":"angular","permalink":"https://nnorland.github.io/tags/angular/"}]},{"title":"认识WebSocket","date":"2016-10-21T08:29:22.000Z","path":"2016/10/21/JavaScript/web-socket-first/","text":"在HTML5规范中，我最喜欢的Web技术就是正迅速变得流行的WebSocket API。WebSocket提供了一个受欢迎的技术，以替代我们过去几年一直在用的Ajax技术。这个新的API提供了一个方法，从客户端使用简单的语法有效地推动消息到服务器。让我们看一看HTML5的WebSocket API：它可用于客户端、服务器端。而且有一个优秀的第三方API，名为Socket.IO。1. 什么是WebSocket API?WebSocket API是下一代客户端-服务器的异步通信方法。该通信取代了单个的TCP套接字，使用ws或wss协议，可用于任意的客户端和服务器程序。WebSocket目前由W3C进行标准化。WebSocket已经受到Firefox 4、Chrome 4、Opera 10.70以及Safari 5等浏览器的支持。WebSocket API最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。WebSocket并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而WebSocket允许跨域通信。Ajax技术很聪明的一点是没有设计要使用的方式。WebSocket为指定目标创建，用于双向推送消息。2. WebSocket API的用法只专注于客户端的API，因为每个服务器端语言有自己的API。下面的代码片段是打开一个连接，为连接创建事件监听器，断开连接，消息时间，发送消息返回到服务器，关闭连接。12345678910111213141516171819202122&#x2F;&#x2F; 创建一个Socket实例var socket &#x3D; new WebSocket(&#39;ws:&#x2F;&#x2F;localhost:8080&#39;);&#x2F;&#x2F; 打开Socketsocket.onopen &#x3D; function(event) &#123; &#x2F;&#x2F; 发送一个初始化消息 socket.send(&#39;I am the client and I\\&#39;m listening!&#39;); &#x2F;&#x2F; 监听消息 socket.onmessage &#x3D; function(event) &#123; console.log(&#39;Client received a message&#39;,event); &#125;; &#x2F;&#x2F; 监听Socket的关闭 socket.onclose &#x3D; function(event) &#123; console.log(&#39;Client notified socket has closed&#39;,event); &#125;; &#x2F;&#x2F; 关闭Socket.... &#x2F;&#x2F;socket.close()&#125;;让我们来看看上面的初始化片段。参数为URL，ws表示WebSocket协议。onopen、onclose和onmessage方法把事件连接到Socket实例上。每个方法都提供了一个事件，以表示Socket的状态。onmessage事件提供了一个data属性，它可以包含消息的Body部分。消息的Body部分必须是一个字符串，可以进行序列化/反序列化操作，以便传递更多的数据。WebSocket的语法非常简单，使用WebSockets是难以置信的容易……除非客户端不支持WebSocket。IE浏览器目前不支持WebSocket通信。如果你的客户端不支持WebSocket通信，下面有几个后备方案供你使用：Flash技术 —— Flash可以提供一个简单的替换。 使用Flash最明显的缺点是并非所有客户端都安装了Flash，而且某些客户端，如iPhone/iPad，不支持Flash。AJAX Long-Polling技术 —— 用AJAX的long-polling来模拟WebSocket在业界已经有一段时间了。它是一个可行的技术，但它不能优化发送的信息。也就是说，它是一个解决方案，但不是最佳的技术方案。由于目前的IE等浏览器不支持WebSocket，要提供WebSocket的事件处理、返回传输、在服务器端使用一个统一的API，那么该怎么办呢？幸运的是，Guillermo Rauch创建了一个Socket.IO技术。3. 带Socket.IO的WebSocketSocket.IO是Guillermo Rauch创建的WebSocket API，Guillermo Rauch是LearnBoost公司的首席技术官以及LearnBoost实验室的首席科学家。Socket.IO使用检测功能来判断是否建立WebSocket连接，或者是AJAX long-polling连接，或Flash等。可快速创建实时的应用程序。Socket.IO还提供了一个NodeJS API，它看起来非常像客户端API。建立客户端Socket.IOSocket.IO可以从GitHub下载，可以把socket.io.js文件包含到页面中：1&lt;script src=\"http://cdn.socket.io/stable/socket.io.js\"&gt;&lt;/script&gt;此时，Socket.IO在此页面上是有效的，是时候创建Socket了：12345678910111213141516171819202122232425// 创建Socket.IO实例，建立连接var socket= new io.Socket('localhost',&#123; port: 8080&#125;);socket.connect();// 添加一个连接监听器socket.on('connect',function() &#123; console.log('Client has connected to the server!');&#125;);// 添加一个连接监听器socket.on('message',function(data) &#123; console.log('Received a message from the server!',data);&#125;);// 添加一个关闭连接的监听器socket.on('disconnect',function() &#123; console.log('The client has disconnected!');&#125;);// 通过Socket发送一条消息到服务器function sendMessageToServer(message) &#123; socket.send(message);&#125;Socket.IO简化了WebSocket API，统一了返回运输的API。传输包括：WebSocketFlash SocketAJAX long-pollingAJAX multipart streamingIFrameJSONP polling你还可以设置任意的Socket.IO构造器的第二个选项，选项包括：port - 待连接的端口transports - 一个数组，包含不同的传输类型transportOptions - 传输的参数使用的对象，带附加属性Socket.IO还提供了由本地WebSocket API提供的普通连接、断开连接、消息事件。Socket还提供了封装每个事件类型的方法。四、NodeJS和Socket.IO联合开发Socket.IO提供的服务器端解决方案，允许统一的客户端和服务器端的API。使用Node，你可以创建一个典型的HTTP服务器，然后把服务器的实例传递到Socket.IO。从这里，你创建连接、断开连接、建立消息监听器，跟在客户端一样。一个简单的服务器端脚本看起来如下：1234567891011121314151617181920212223242526// 需要HTTP 模块来启动服务器和Socket.IOvar http= require('http'), io= require('socket.io');// 在8080端口启动服务器var server= http.createServer(function(req, res)&#123; // 发送HTML的headers和message res.writeHead(200,&#123; 'Content-Type': 'text/html' &#125;); res.end('&lt;h1&gt;Hello Socket Lover!&lt;/h1&gt;');&#125;);server.listen(8080);// 创建一个Socket.IO实例，把它传递给服务器var socket= io.listen(server);// 添加一个连接监听器socket.on('connection', function(client)&#123; // 成功！现在开始监听接收到的消息 client.on('message',function(event)&#123; console.log('Received message from client!',event); &#125;); client.on('disconnect',function()&#123; clearInterval(interval); console.log('Server has disconnected'); &#125;);&#125;);你可以运行服务器部分，假定已安装了NodeJS，从命令行执行：1$ node socket-server.js现在客户端和服务器都能来回推送消息了！在NodeJS脚本内，可以使用简单的JavaScript创建一个定期消息发送器：1234// 创建一个定期（每5秒）发送消息到客户端的发送器var interval= setInterval(function() &#123; client.send('This is a message from the server! ' + new Date().getTime());&#125;,5000);服务器端将会每5秒推送消息到客户端！五、dojox.Socket和Socket.IOPersevere的创建者Kris Zyp创建了dojox.Socket。dojox.Socket以Dojo库一致的方式封装了WebSocket API，用于在客户端不支持WebSocket时，使用long-polling替代。下面是怎样在客户端使用dojox.Socket和在服务器端使用Socket.IO的例子：1234567891011121314151617181920var args, ws= typeof WebSocket!= 'undefined';var socket= dojox.socket(args= &#123; url: ws? '/socket.io/websocket' : '/socket.io/xhr-polling', headers:&#123; 'Content-Type':'application/x-www-urlencoded' &#125;, transport: function(args, message)&#123; args.content = message; // use URL-encoding to send the message instead of a raw body dojo.xhrPost(args); &#125;;&#125;);var sessionId;socket.on('message', function()&#123; if (!sessionId)&#123; sessionId= message; args.url += '/' + sessionId; &#125;else if(message.substr(0, 3) == '~h~')&#123; // a heartbeat &#125;&#125;);dojox.socket.Reconnect还创建了在套接字失去连接时自动重连。期待包含dojox.Socket的Dojo 1.6版本早日发布。六、实际应用和WebSocket资源有很多WebSocke的实际应用。WebSocket对于大多数客户机-服务器的异步通信是理想的，在浏览器内聊天是最突出的应用。WebSocket由于其高效率，被大多数公司所使用。","updated":"2023-01-15T02:37:22.882Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://nnorland.github.io/tags/WebSocket/"}]},{"title":"progressive-web","date":"2016-10-21T08:24:01.000Z","path":"2016/10/21/FrontEnd/progressive-web/","text":"Progressive Web App 是 Google 在 Web 平台开始推广的一个新概念，可以理解为是尽可能借助目前的新技术（比如 Service Worker ， Push Notification 及其他展现层的新技术），让 Web App 的体验无限接近 Native App 。参考文章:https://addyosmani.com/blog/getting-started-with-progressive-web-apps/原文Getting started with Progressive Web AppsThere’s been much welcome discussion about Progressive Web Apps lately. They’re still a relatively new model, but their principles can equally enhance apps built with vanilla JS, React, Polymer, Angular or any other framework. In this post, I’ll summarise some options and reference apps for getting started with your own PWApp today.What is a Progressive Web App?A Progressive Web App uses modern web capabilities to deliver an app-like user experience. They evolve from pages in browser tabs to immersive, top-level apps, maintaining the web’s low friction at every moment.** It’s important to remember that Progressive Web Apps work everywhere but are supercharged in modern browsers. Progressive enhancement is a backbone of the model. **Aaron Gustafson likened progressive enhancement to a peanut M&amp;M. The peanut is your content, the chocolate coating is your presentation layer and your JavaScript is the hard candy shell. This layer can vary in color and the exerience can vary depending on the capabilities of the browser using it.Think of the candy shell as where many Progressive Web App features can live. They are experiences that combine the best of the web and the best of apps. They are useful to users from the very first visit in a browser tab, no install required.As the user builds a relationship with these apps through repeat use, they make the candy shell even sweeter - loading very fast on slow network connections (thanks to Service Worker), sending relevant Push Notifications and having a first-class icon on the user’s homescreen that can load them as fullscreen app experiences. They can also take advantage of smart web app install banners.Web app install banners for engagement, launch from the user’s homescreen, splash screen in Chrome for Android, works offline with Service WorkerProgressive Web Apps are:Progressive - Work for every user, regardless of browser choice because they’re built with progressive enhancement as a core tenet.Responsive - Fit any form factor, desktop, mobile, tablet, or whatever is next.Connectivity independent - Enhanced with service workers to work offline or on low quality networks.App-like - Use the app-shell model to provide app-style navigations and interactions.Fresh - Always up-to-date thanks to the service worker update process.Safe - Served via TLS to prevent snooping and ensure content hasn’t been tampered with.Discoverable - Are identifiable as “applications” thanks to W3C manifests and service worker registration scope allowing search engines to find them.Re-engageable - Make re-engagement easy through features like push notifications.Installable - Allow users to “keep” apps they find most useful on their home screen without the hassle of an app store.Linkable - Easily share via URL and not require complex installation.Progressive Web Apps also aren’t unique to Chrome for Android. Below we can see the Pokedex Progressive Web App working in Firefox for Android (Beta) with early Add to Homescreen and Service Worker caching features running just fine.Progressive web apps working in Firefox for AndroidOne of the nice aspects of the “progressive” nature to this model is that features can be gradually unlocked as browser vendors ship better support for them. Progressive Web Apps such as Pokedex also of course work great in Opera on Android too with a few notable differences in implementation:Progressive web apps working in Opera for AndroidFor diving deeper into Progressive Web Apps, read Alex Russell’s original blog post introducing them. Paul Kinlan also started a very useful Stack Overflow tag for Progressive Web Apps worth checking out.PrinciplesWeb App ManifestThe Manifest for Web applications is a simple JSON file that gives you, the developer, the ability to control how your app appears to the user in the areas that they would expect to see apps (for example the device home screen), direct what the user can launch and more importantly how they can launch itThe manifest enables your web app to have a more native-like presence on the user’s homescreen. It allows the app to be launched in full-screen mode (without a URL bar being present), provides control over the screen orientation and in recent versions of Chrome on Android supports defining a Splash Screen and theme color for the address bar. It is also used to define a set of icons by size and density used for the aforementioned Splash screen and homescreen icon.Add to homescreen, launch from homescreen and full-screen app-like experiences.A sample manifest file can be found in Web Starter Kit and over in the Google Chrome samples. Bruce Lawson wrote a Manifest Generator and Mounir Lamouri has also written a handy Web Manifest validator worth checking out.In my personal projects, I rely on realfavicongenerator to generate the correctly sized icons for both the Web App manifest and for use across iOS, desktop and so on. The favicons Node module is also able to achieve a similar output as part of your build process.Chromium-based browsers (Chrome, Opera etc.) support Web App manifests today with Firefox actively developing support and Edge listing them as under consideration. WebKit/Safari have not yet posted public signals about their intents to implement the feature just yet.For more details, read Installable Web Apps with the WebApp Manifest in Chrome for Android on Web Fundamentals.Add to Home Screen BannerChrome on Android has support adding in your site to the homescreen for a while now, but recent versions also support proactively suggesting sites be added using native Web App install banners.The voice memos demo application displaying a webapp install banner prompt in Chrome for AndroidIn order for the app install prompts to display your app must:Have a valid Web App manifestBe served over HTTPS (see letsencrypt for a free certificate)Have a valid service worker registeredBe visited twice, with at least 5 minutes between visitsA number of App Install banner samples are available, covering basic banners through to more complex use-cases like displaying related applications.Service Worker for offline cachingA service worker is a script that runs in the background, separate from your web page. It responds to events, including network requests made from pages it serves. A service worker has an intentionally short lifetime.It wakes up when it gets an event and runs only as long as it needs to process it. Service worker allows you to use the Cache API to cache resources and can be used to provide users with an offline experience.Service workers are powerful for offline caching but they also offer significant performance wins in the form of instant loading for repeat visits to your site or web app. You can cache your application shell so it works offline and populate its content using JavaScript.Service worker caching of the application shell, allowing it to load without the networkA comprehensive set of service worker samples are available over on Google Chrome samples. Jake Archibald’s offline cookbook is a must-read and I highly recommend trying out Paul Kinlan’s your first offline web app walkthrough if new to service worker.Our team also maintain a number of Service Worker helper utilities and build tools that we find useful for reducing the overhead in getting Service Worker setup. They’re listed over on Service Worker Libraries. The two main ones are:sw-precache: a build-time tool that generates a service worker script useful for precaching your web app shellsw-toolbox: a library providing runtime caching for infrequently used resourcesJeff Posnick wrote a quick primer on sw-precache called Offline-first, fast, with the sw-precache module and a codelab on the same tool that you might find useful.Dean Hume also has a very well written post on getting started with sw-toolbox worth checking out.Chrome, Opera and Firefox have all implemented support for Service Worker with Edge having positive public signals about interest in the feature. Safari briefly mentioned interest in it via one engineer’s proposed five year plan.Push Notifications for re-engagementPush notifications allow your users to opt-in to timely updates from sites they love and allow you to effectively re-engage them with customized, engaging content.Effectively, you can build web apps that users can engage with outside of a tab. The browser can be closed and they don’t even need to be actively using your web app to engage with your experience. The feature requires both service worker and a Web App manifest, building on some of the features summarised earlier.The Push API is implemented in Chrome, in development in Firefox and under consideration in Edge. There are no public signals from Safari about their intent to implement this feature just yet.Push Notifications on the Open Web is a comprehensive intro to getting Push setup by Matt Gaunt and a Push Notifications codelab is also available on Web Fundamentals.Web push notification on the Facebook mobile siteMichael van Ouwerkerk from the Chrome team also has a 6 min intro to Push if you’re more video inclined.Layering in advanced featuresRemember, your user experience can have different levels of sweetness depending on the browser being used to view your web app. You’re in control of the hard candy shell.Additional features coming to the web platform such as Background Syncronisation (for data sync with a server even when your web app is closed) and Web Bluetooth (for talking to Bluetooth devices from your web app) can also be layered into your Progressive Web App in this manner.One-shot Background Sync has been enabled in Chrome and Jake Archibald has a video of his Offline wikipedia app and article demonstrating it in action. Francois Beaufort also has a number of Web Bluetooth samples available if interested in trying out that API.Framework-friendlyThere’s really nothing stopping you from applying any of the above principles to an existing application or framework you’re building with. A few other principles worth keeping in mind while building your Progressive Web App are the RAIL user-centric performance model and FLIP based animations.I’m hopeful that during 2016, we’ll see an increasing number of boilerplates and seed projects organically baking in support for Progressive Web Apps as a first-class citizen. Until then, the barrier to adding these features to your own apps isn’t very high and are imo, quite worth the effort.ArchitectureThere are different levels of how “all-in” one goes on the Progressive Web App model, but one common approach taken is architecting them around an Application Shell. This is not a hard requirement, but does come with several benefits.The Application Shell architecture encourages caching your application shell (the User Interface) so it works offline and populate its content using JavaScript. On repeat visits, this allows you to get meaningful pixels on the screen really fast without the network, even if your content eventually comes from there. This comes with significant performance gains.The application shell being visualised as breaking down the UI of your app, such as the drawer and the main content areaJeremy Keith recently commented that in this type of model perhaps server-side rendering should not be viewed as a fallback but client-side rendering should be looked at as an enhancement. This is fair feedback.In the Application Shell model, server-side rendering should be used as much as possible and client-side progressive rendering should be used as an enhancement in the same way that we “enhance” the experience when service worker is supported. There are many ways this can ultimately be approached.My recommendation is reading our write-up on the architecture and evaluating how similar principles could be best applied to your own application and stack.Getting Started BoilerplatesApplication ShellThe app-shell repository contains a near-complete implementation of the Application Shell architecture. It has a backend written in Express.js and a front-end written in ES2015.Given that it covers both client and server-side portions of the model and there’s quite a lot going on there, it will take some time to familiarise yourself with the codebase. It’s otherwise our most comprehensive Progressive Web App starting point right now. Docs will be our next focus for this project.Polymer Starter KitView on GitHubThe official starting point for Polymer web apps supports the following Progressive Web App features:Web Application manifestChrome for Android SplashscreenService Worker offline caching with the Platinum SW elementsPush Notifications (manual setup required) with the Platinum Push elementsPolymer starter kit displaying progressive web app features built inThe current version of PSK is missing support for some of the more advanced performance patterns (e.g Application Shell model, async loading) you find in some Progressive Polymer web apps.We aim to try baking these patterns into PSK in 2016, but early experiments around this can be found in the Polymer Zuperkulblog app by Rob Dodson and the excellent Polymer Perf Patterns talk by Eric Bidelman.Web Starter KitView on GitHubOur opinionated starting point for new vanilla projects includes the following Progressive Web App features:Web Application manifestChrome for Android SplashscreenService-worker pre-caching thanks to sw-precacheIf you have a preference for working with vanilla JS/ES2015 and are unable to use Polymer, Web Starter Kit may prove useful as a reference point you can reuse or steal code snippets from.Progressive Web Apps with and without frameworksA number of open-source Progressive Web Apps have already been built by members of the community both with and without JS libraries and frameworks. If you’re looking for inspiration, the below repos might prove useful as reference. They’re also just pretty damn good apps.Progressive web apps implemented using React, Polymer, Virtual DOM and AngularJSVanilla JSVoice Memos by Paul Lewis is built using a similar architecture to app-shell (write-up)Offline Wikipedia by Jake Archibald (video)Air Horner by Paul KinlanGuitar Tuner by Paul Lewis (write-up)PolymerZuperkulblog by Rob Dodson (slides)Snapdrop - an Apple Airdrop-like PWApp built with Polymer and Web RTCReactiFixit by Jeff Posnick - uses sw-precache for application shell caching (slides)Virtual-DOMPokedex by Nolan Lawson - excellent progressive web app applying a “do everything in a web worker” approach to help with progressive rendering. (write-up)Angular.jsTimey.in by Kenneth Auchenberg - also uses sw-precache for resource precachingThe Angular team have also started an early ng2-application-shell project based on the app-shell architecture.Closing notesAs mentioned, Progressive Web Apps are still in their infancy but it’s an exciting time to play around with the methodologies behind them and see how well they can apply to your own web apps.Paul Kinlan is currently planning out the Web Fundamentals guidance on Progressive Web Apps and if you have input on areas you would like to see covered, please feel free to comment on-thread.Further readingProgressive Web Apps: Escaping Tabs Without Losing Our SoulWhy Progressive Web Apps Are The Future Of Web DevelopmentProgressive Web Apps: ready for primetimeMaking a Progressive App with ServiceWorkerProgressive Web Apps Are the FutureProgressive Web App: A New Way to Experience MobileWeb Fundamentals: Progressive Web AppsIntroducing Pokedex.org: a progressive webapp for Pokémon fansChrome Developer Summit Recap: Progressive Web AppsAddy OsmaniEngineer at Google working on open web tooling","updated":"2023-01-15T02:37:22.879Z","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://nnorland.github.io/categories/FrontEnd/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"}]},{"title":"subscribe/publish 订阅/发布模式","date":"2016-10-20T15:30:52.000Z","path":"2016/10/20/JavaScript/Subscribe-Publish/","text":"我们先引出问题的所在，这里使用一个订单系统：在一个电子商务系统中，现在我们有订单模块，和信息模块两个主要模块，当下单成功时，我们用要发送订单信息的给客户。下面是一个简单的解决办法，我们在一个类中调用另一个类的方法。12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F; 订单类，存储订单的所有变量和函数function Order( goods )&#123; this.goods &#x3D; goods;&#125;Order.prototype &#x3D; &#123; done: function()&#123; &#x2F;&#x2F; 订单完成代码 this.sendSuccessMsg(); &#125;, sendSuccessMsg: function()&#123; var message &#x3D; new Message(); message.sendMsg(this.goods) &#125;&#125;&#x2F;&#x2F; 消息类，具备各种消息功能函数function Message()&#123;&#125;Message.prototype &#x3D; &#123; sendMsg: function( goods )&#123; alert(&quot;商品名：&quot;+goods.name+&quot;\\n&quot;+&quot;价格：&quot;+goods.price); &#125; &#x2F;&#x2F;其它信息模块的方法&#125;var order &#x3D; new Order(&#123; name:&quot;索尼耳机&quot;, price:100&#125;)order.done() &#x2F;&#x2F;弹出商品的信息&#96;&#96;&#96; 经过简单的分析代码，我们可以发现一些问题，首先，Order和Message紧耦合，一般来说，当一个类进行的修改会需要另一个类的修改这就是耦合。在这里，比较直接的一个问题，当我们改改了Message类中的sendMsg方法的名字或者参数时，Order类中的相应函数名和参数也要跟着修改。知道了这种方法的问题，下面我们就来看看如何用Publish&#x2F;Subscribe模式改进这段代码.Publish&#x2F;Subscribe模式是一种消息通信模式，信息发布一方叫发布者，信息的接收方叫订阅者。下面是一个根据Publish&#x2F;Subscribe模式的简易系统var subpub = {};(function( subpub ){var list = {};subpub.publish = function(topic,msg){for(var i = 0; i&lt;list[topic].length; i++) {list[topic]i;}}subpub.subscribe = function( topic,listener){if(!list[topic]) list[topic] = [];list[topic].push(listener);}})( subpub )// 测试subpub.subscribe(‘foo’, function(msg){alert(msg);});subpub.publish(‘foo’, ‘Hello World!’)1将这个事件管理小系统应用到之前的订单系统中，进行解耦。function Order( goods ){this.goods = goods;}Order.prototype = {done: function(){// 订单完成代码this.sendSuccessMsg();},sendSuccessMsg: function(){subpub.publish(‘order/done’,this.goods);}}function Message(){subpub.subscribe(‘order/done’,this.sendMsg);}Message.prototype = {sendMsg: function( goods ){alert(“商品名：”+goods.name+”\\n”+”价格：”+goods.price);}//其它信息模块的方法}var message = new Message();var order = new Order({ name:”索尼耳机”, price:100});order.done() //弹出商品的信息现在，我们发现Message和Order类不关心彼此如何实现。修改某个类中的函数不用考虑是否会影响到另一个类。不过有重要的一点是保存的事件标题。","updated":"2023-01-15T02:37:22.880Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"}]},{"title":"foo-bar","date":"2016-09-06T06:03:58.000Z","path":"2016/09/06/杂记/foo-bar/","text":"“英文单词foo，不同的字典对其解释相去甚远，一说来自中国“福”字的发音，又有解释为二战时期的一种武器。然而若把众多的解释放在编程领域，关于 foobar的说法是我认为最为贴切的解释。foobar又为foo-bar，其中bar是beyond all recognition的缩写，通俗点就是无法识别，一塌糊涂的意思。而foo是fu的变体，fu是英语习语fuck-up的缩写，同样是一团糟的意思。于是，若你有些编程经验，我想你应该已经明白了为何如今许多编程实例所涉及的事物均被冠名为foo”—-摘自：编程黑马真言，王轶男。至今约有212 个RFC， 或者约7%的RFC， 从[RFC269]开始，包括了术语’foo’,’bar’ 或’foobar’作为伪变量而没有任何适当的解释或定义。这可能被认为是微不足道的，但一些新来者，特别是那些非英语国家的人，在理解这些术语时会遇到困难。本文纠正这一问题。","updated":"2023-01-15T02:37:22.885Z","categories":[{"name":"杂记","slug":"杂记","permalink":"https://nnorland.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://nnorland.github.io/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"jQuery插入元素动态绑定事件","date":"2016-08-29T03:53:00.000Z","path":"2016/08/29/JavaScript/jquery-on-append/","text":"jQuery on()方法, 在选择元素上绑定一个或多个事件的事件处理函数。在jQuery 1.7以及之后的版本，.on()方法 提供绑定事件处理程序所需的所有功能。帮助从旧的jQuery事件方法转换， .bind(), .delegate(), 和 .live().要删除的.on()绑定的事件，请参阅.off()。jQuery on()方法描述如下1.on( events [, selector ] [, data ], handler(eventObject) )jquery中绑定事件一般使用bind，或者click，但是这只能是对已经加载好的元素定义事件，那些后来添加插入的元素则需要另行绑定。在1.7版本以前使用live。但是在1.7版本以后推荐使用on。这里介绍jQuery中如何给动态添加的元素绑定事件在实际开发中会遇到要给动态生成的html元素绑定触发事件的情况123&lt;div id=\"testdiv\"&gt; &lt;ul&gt;&lt;/ul&gt;&lt;/div&gt;需要给&lt;ul&gt;里面动态添加的&lt;li&gt;标签添加click事件123$(\"#testdiv ul\").on(\"click\",\"li\", function() &#123; //do something here &#125;);当事件冒泡到#testdiv ul时，检测事件的target，如果与传入的选择符（这里是li）匹配，就触发事件，否则不触发。一个简单的事件绑定如 $(&#39;button&#39;).on(&#39;click&#39;,function(){}); 与bind()无二样。","updated":"2017-01-11T08:45:00.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"}]},{"title":"财务自由","date":"2016-08-24T14:08:33.000Z","path":"2016/08/24/杂记/Financial-independence/","text":"财务自由，就是当你不工作的时候，也不必为金钱发愁，因为你有其他投资。当工作不是你养家糊口的惟一手段时，你便自由了，因而你也获得了快乐的基础，也达到了财务自由.—摘自百度百科财务自由标准原则： 创造资产 减少负债管理日常开支公式表达 财务自由=被动收入&gt;花销35岁能财务自由吗 ? 不可能 ? 没出息.2016-08-31先定一个能达到的小目标,比方说我先挣它一个亿.","updated":"2016-08-31T13:04:50.000Z","categories":[{"name":"杂记","slug":"杂记","permalink":"https://nnorland.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://nnorland.github.io/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"陆龟常见病的小窍门还有常识","date":"2016-08-23T02:56:03.000Z","path":"2016/08/23/杂记/tortoise-treat-the-disease/","text":"转载自爬行天下的一位养龟近十年的龟友五块钱的帖子.附上原帖地址:养龟近十年，我碰到一些陆龟常见病的小窍门还有常识，希望对新手有帮助。养龟近十年，陆龟常见病的小窍门还有常识，希望对新手有帮助[第二季]一、常见病首先是感冒这里治疗方法我就不多废话了，坛子里很多高人已经说过，现在就讲讲一些该注意的事项。龟龟感冒最常见的原因呢，多数是着凉，值得注意的是，大家普遍都认为温度低了才会着凉，其实不一定，感冒多数是因为突然着凉，记得是“突然“。打个比方，如果环境温度低于10度龟就会感冒，如果温度从25度慢慢下降（24至48小时），降到了8度，龟还不一定会感冒。但是如果从25度突然下降到13度（2至8小时），大多数要出问题。这里是要提醒各位，在冬天给龟箱打扫的时候，把龟拿出温暖的龟箱的时候，千万要注意，周围很多朋友就是因为打扫的时候把龟拿出来才几分钟，第二天马上出问题。PS：着凉引起的感冒问题不大。怕的是之前碰过一例，是细菌感染的感冒，基本无解，后来疏忽大意还传染了两只缅陆，同样无解，阵亡。肺炎其实肺炎就是感冒的升级版，感冒治疗不及时，就会引发肺炎，初期可以按照感冒的方式治疗，能有见效，中期需要注射治疗，后期基本无解。本人百试不爽的一个方法就是，用庆大霉素滴鼻孔，每天三次，5天见效。方便好用。肠胃炎其实肠胃炎不仅仅是豹龟的专利，几乎所有的陆龟都要遭受折磨，如果你的爱龟还没有过，那恭喜你，等着吧！肠胃炎的表现症状最明显的就是爱喝水，拉稀，果冻状便便（这里要科普一下，很多人认为果冻状便便是原虫感染，没错，但是需要补充的是，白色的果冻状便便才是你们所说的”原虫感染“，记得是白色。 如果是墨绿色，深色的果冻状便便，那一般是肠胃炎。）肠胃炎的严重程度主要看龟的精神，喝水量，还有拒食的程度判断。治疗方式也是按照肠胃炎的方法，这里就不多说了，我个人的主张是用黄连素，纯中药无副作用。PS：肠胃炎是最常见，也是最好治疗的一种疾病。但是如果发现眼球凹陷，长期拒食，赶紧电解质补充能量，不能拖，必要时候采取注射治疗，这种情况不同个体解决方法上有点差异，很难说清楚，但是要乐观，存活率是有的。线虫线虫呢，就是大家肉眼看得见的白色细条的寄生虫，出现这个东西，要打虫，但也不能着急，选龟状态好的时候治疗，如果有并发症，比如患肠胃炎的同时有虫，切记是先治疗后打虫，如果你先打虫了，几乎可以断定你在谋杀！线虫呢，最大的影响就是让你的龟龟怎么吃都长不大（营养都被吸走了），所以定期驱虫是必要的，这是一个持久战。原虫说到原虫感染其实大家不要紧张，只要是龟，体内都会有原虫(肉眼看不见)，起到平衡作用，只是有时候里面的状态失衡了，乌龟才会表现出病态，诸如拉白色果冻状便便，一般的抗原虫感染药治疗即可见效，这里给大家科普下，体内原虫失衡，大量繁殖，乌龟状态下降，拉白色果冻状便便，要服用抗原虫药物，记住是抗，不是杀原虫，如果一只龟体内没有原虫，那此龟不是模型就是尸体。PS：真正的原虫感染，对龟是可怕的字眼，是无解的，如果在失衡的时候没控制好，原虫扩散感染到了内脏，才叫原虫感染，那时候会便血，吐血，一般会突然暴毙，很恐怖，救不活。曾经接过一只，实在没办法拿去找认识的兽医朋友，兽医就一句话：”原虫感染了，要不要帮你们把壳弄出来留做纪念？“内伤内伤的龟是我碰过最多的，多数是网购或者菜市场买来的，内伤轻的状态差，重的伤口积血腐甲，内出血，治疗方法我也没辙，只能泡葡萄糖，增加体质，上点消炎药(可注射）或云南白药，至于能不能熬过去，那就看龟的造化了。口腔炎口腔炎可以说是我养龟这么多年以来最头疼烦心的病了，听起来不是大病，但是很罗嗦，治疗时容易反反复复，也有挂掉的风险。口腔炎的表现症状为拒食，食物咬一口吐掉，想吃吃不了，干呕，老张嘴。出现这个情况你就要撬开龟的嘴巴，看看口腔的颜色，如果粉色有点白，那是正常的，大部分正常中央部分小块地方颜色较深，也是正常的。就可以考虑看看是其他部位的问题。患口腔炎的舌头个跟口腔，是鲜艳的红色，感觉跟充血似的，这个要留意，还有碰过部分口腔炎的口腔内部是红色斑点状，还有红色絮状，五花八门，治疗的时候最头疼就是不吃东西，一般我的治疗方法，就是撬开嘴巴，用阿莫西林粉末拌水滴入口腔，能有见效。如果个体大点的龟，直接粉末倒入口腔，效果更显著，前提是注意量，注意安全。PS:疱疹跟口腔炎症状相似，没有有效的治疗方法，至少我没有成功案例。结石说到结石那一般来说肯定是苏卡达，没跑，苏卡达在个体比较小的时候很容易结石，但是个体长到大概18厘米以上的时候，结石的情况几乎没有了。 结石的话解决办法很多，我就不多说，百度一下一大堆，这里给的建议是:提前做好工作。 所以每次给苏卡达泡澡之前，建议用淋蓬头上下冲刷苏卡达的腹部还有小PP，起到按摩作用，也就一分钟，然后再泡澡，这样之后，你就会发现你的小苏结石的情况大大减少，省心很多。所以我们提倡的是能预防的提前预防，这样才能无后顾之忧。腐甲腐甲的治疗方法一直存在很多争议。即使是陆龟，也是有患腐甲的风险，大多数陆龟的腐甲，都很好治。最难治疗的是由于硬伤，伤口有积血水，感染后导致的腐甲（如果是这种情况，腹甲10CM以下基本判死刑）；还有一种腐甲，是龟在尿尿的时候因为懒，就爬在尿尿上久了，导致的腐甲；还有就是长期有液态水在腹部导致的。（腐甲后一定要保持环境干燥）很多人说腐甲要用高锰酸钾泡水，双氧水消毒，这些都是没错的，但是前提是龟的腐甲部位已经挑干净了，否则就算泡过后，水还是有少许积在里面，这样腐甲只重不轻。 至于双氧水我上面说过了，慎用，而且双氧水杀菌后，就转化成普通的水了，如果腐甲没挑干净，积在缝里，也是很不好的。这里本人推荐一个多年的方法，就是用甲基蓝找到腐甲位置后，挑干净，用云南白药（白色粉末那种，粉末状药物也有利于保持伤口干燥） 直接敷上去，敷紧一些。然后放到干燥的地方静养(严重可配合消炎药物），三到四天会有明显的见效，不过比较费钱。流眼泪，睁眼慢多数是环境过于干燥，粉尘太多引起的，改善环境可以解决。眼睛发红，肿胀，流脓，有血丝的话，去药店买一瓶人用的氯霉素滴眼液，一天滴两次，爽快解决！PS：当我们摸龟龟的时候，记得千万要洗手过后，因为人身上带的细菌也不少，更不能小瞧。（目前有发现洗衣液会导致龟的失明，所以就算洗过手，也要保证手冲洗干净了。）二、心得甲基蓝妙用这里给大家介绍一下甲基蓝，相信养鱼的朋友肯定认识，鱼店都有卖，价钱不贵，用处很广。如果龟友轻微腐甲，或者皮外伤，或者有肠胃炎。新手不敢确定的时候，用甲基蓝最适合不过了，甲基蓝除了可以杀菌，还能起到病部定位作用。甲基蓝放进水里稀释，泡龟可以找到细菌感染位置，判断肠胃炎，定位腐甲位置的作用。腐甲不仅仅是那些看得到的地方，有些小地方刚开始看不出来，其实也有点隐患了，所以很多朋友在给龟治疗腐甲的时候，经常旧伤没好，新伤又来。就是因为之前隐患的伤口看不出来，没有及时控制好。所以在治疗前用甲基蓝泡龟后，会发现所有腐甲的地方都会被染成淡蓝色，只要是淡蓝色的地方，就说明这块地方有炎症了，这样下手就恨容易，是不是很方便呢？还有肠胃炎，我们知道肠胃炎会拉果冻状的便便，如果把果冻状的便便放入甲基蓝稀释的水中，也能发现便便被染成蓝色，就是因为便便里面存在炎症。 所以觉得龟状态不好时，用稀释的甲基蓝泡澡，如果发现龟PP周围有蓝染色，可以初步判断龟可能要患肠胃炎了，可以争取时间及时治疗。PS：甲基蓝主要用于简单鱼病的消毒治疗，还有消毒鱼缸，副作用很小，几乎没影响，适用于陆龟刚入手时的病部检查，本人屡试不爽！谨慎使用双氧水双氧水能杀菌，固然是好，但是别忘了刺激性太大，其实个人感觉非常不适合龟，以前本人喜欢用双氧水给龟治疗，杀菌的时候见到冒白色汽包的时候会特别有成就感，但是效果却大打折扣。在用双氧水给腐甲的龟使用的时候，记得如果有出血或者皮薄了，万万不要随意使用双氧水。楼主我曾经给过一只腐甲的黄额上过双氧水，怕消毒不干净，涂了N多次，当时龟龟痛苦的就别说了，第二天暴毙。 后来跟兽医朋友喝茶，他说一般不会暴毙的，估计是给双氧水割，疼到死的。 特别是一些敏感的龟，如果太疼，就算不至死，但是恐惧感也会让龟抑郁而终，其实龟也是有性格脾气的。灌药的小心得如果龟龟生病，泡澡的话效果太慢，打针的话没经验不敢动手，怎么办呢。 见效最快，又最不具难度的就是给龟灌药了。这里就需要准备一个注射器，一只套在注射器上面的胶管。胶管斜着剪，一个完美的灌药工具就诞生啦！我拿肠胃炎为例，上次帮朋友治一肠胃炎缅陆，挺严重的，上吐下泻。这时我跟朋友友把香蕉搅烂，把黄连素搅烂，混点清水搅拌，尽量稀一点。用针管吸上去，把龟的嘴撬开（撬开也是个技术活，这里提一下，其实只要把龟竖立，龟会把头伸出来，这时悄悄用手指卡住龟的后颈处，就缩不回去了，然后按住龟的两颊，往前一点再往下拉，嘴就开了） ，撬开后把注射器的塑料管伸至喉咙处，慢慢挤进去（有些龟不配合，不吞怎么办呢，这里有个小方法，只要龟含住药没吞的话，这时候旁边只要有个人忽然来个动作吓一吓龟，它一紧张吸气，药就爽快的下去了！百试不爽！）PS：这只缅陆当时给它灌了药后，居然把药还有一些未消化的食物一起吐出来了，PP也拉了一些稀。但是明显精神好了很多，判断这时候可能肚子里也没多少东西了，于是再给他灌了一些，静养。 第二天明显有点食欲了，于是每天继续灌。 5天后痊愈。关于龟的个体如果是新手养龟，建议入手腹甲10CM以上的，这样存活率会大很多。在我治疗龟的时候，如果10CM以下的，要尽量避免用药，因为药量不好掌握，而且个体脆弱。许多新手的小龟我想应该是被药毒死的多。本人碰上10CM以下的龟，一般都会十分谨慎，因为个体太脆弱。在野生陆龟里，幼体10只里大概会有3到4只的体质是天生较差的(这就是为什么有的龟天生体弱多病，有的龟皮实活泼），一般总共能存活下来5只，已经是相当不错了，这就是大自然优胜劣汰的残酷。现在都是人工养殖，基本上全部都能存活，所以同一批龟里，有体质好跟体质差的分别，同样一个疾病，可能体质好的能存活，体质差的就提前回归大地了。这也是我谨慎的一个原因。在这里我个人的认为是，只有幼体长到了10厘米以上，那才能说的上是度过了一个阶段跟考验，生命力也大大提高。 在我看过的所有龟里，夭折的不少，其中大半都是10CM以下的。新手们也别灰心，慢慢来，龟其实是越养越好养（想信不少老鸟也有同感吧）。感觉龟龟生病了怎么办刚开始发觉情况不对劲，并且判断不出是什么毛病的时候。最好的做法就是别乱用药（特别是10CM以下），一旦发现情况，建议先用电解质，VC,葡萄糖混合泡水，这些用来增加体质，没有害处。 然后继续加温静养，继续观察。龟的体质加强了，一般小问题能自愈。如果情况还不乐观，就要观察是哪出问题。，再做进一步打算。总的来说，在不知道是什么问题的情况下，电解质，VC,葡萄糖混合泡水，加温静养的做法绝对是优先而且可靠的。后记大家要相信自己龟龟的自愈的能力，一般的问题，加温静养可以自愈。 我们要抱着一个态度，用药只是帮助龟自愈，而不是帮他彻底治病。 乌龟靠自身战胜疾病，才是我们饲养者最该做的。我碰过至少一半的龟龟生病，少去打扰，加温静养，都能自愈。后续关于用药问题龟龟小时候容易生病，大多数新手喜欢用药，药量也不能很好把握，这里我给大家点出一个新的问题。不知道有没有人发现，陆龟许多到了大概30CM左右的时候，部分很容易暴毙，特别是豹。在我养龟的这些年里，接触过的有三只的豹子暴毙，两只28CM左右，一只30CM+。还有一只35CM的苏暴毙，18CM的星暴毙。 暴毙前毫无征兆，食欲下降，嗜睡，均三天内S亡。通过解剖有如下发现：豹子1：胃部没有食物残渣，肺部有少许黑点，肝部有硬币大小黑色硬块。豹子2:胃部没有食物残渣，膀胱积水多，肝部同样有黑色硬块，较大。豹子3：胃部少许食物，膀胱有水，肾处有淡黄色绸状物（不明，高手指点），肺部少许黑斑，不硬。苏卡达：找不到问题，但膀胱积尿，戳破后很臭。星：无异常，原因不明。（怀疑原虫）发现共同处最多的为肺部的黑色硬块。初步认为由于龟是冷血动物，排毒跟解毒的能力较差，许多龟在小时候用药过多（是药三分毒），或者菜叶含农药没清洗干净，短时间没有异常，长时间积累下来的毒素经过沉淀集合，到了一定量害了龟（猜测）PS ： 图片好麻烦，图大还要上传电脑，此条留给高手来此讨论，互相学习进步。关于挑食问题解决方法就一个字，饿！ 不能心软。PS：本人发现一个奇方，用螺旋藻碾碎成粉末洒在菜叶上，龟龟吃后BB及其健康！疱疹症状跟口腔炎及其相似，严重后眼睛跟口腔会长白色脓包，传染度极高，适当使用抗生素，没有很有效办法。本人也没有成功案例，但是疱疹情况极少。生长速度个人经验，12~15厘米前，喂饲料生长速度快；15厘米以后，喂菜叶，喂草生长速度快。 此规律对苏无效，苏30CM前几乎神速。混养的问题相信很多朋友都混养，包括本人也是，这里说说几个情况，首先只要一直龟出现问题，要马上隔离开，免得传染。 还有就是肠胃炎也是会传染的。给大家说个恶心的事实，我亲眼见过一直苏把豹的BB给吃了，所以大家一定要注意再注意，不是开玩笑的。保暖问题准备一个热水袋是必要的必要，冬天停电的时候你就明白了。缅陆缅陆算是胆子小的陆龟了，当然也有性格差异，刚入手尽量不要惊吓，我碰过最胆小的一只，惊吓过度甚至会上吐下泻，很夸张，一个小时前吃的东西，拿起来吓一吓都能给你拉出来。排泄问题陆龟排便排尿要么是泡水，要么是太阳暴晒（这个比较凶残）。而且所有陆龟都有一个奇特的能力，就是空气干燥炎热时，会自己排尿来增加空气湿度。入龟的问题这里再次建议新手不要随便入10CM以下的小龟，很容易出问题，以前一朋友搞养殖场的时候，一孵化等蛋黄吸收完了，就大批出出去了，这类龟是非常容易死的，刚破壳的小龟大概有差不多4CM，那些买的5CM左右的龟的朋友，现在你知道情况了么？垫材问题相信很多龟友都考虑过的问题，本人养龟呢，是越来越懒，一开始会买专门的垫材，后来发现瓷砖反铺才是王道，再后来，直接用报纸了，大号小号把报纸一卷就扔，换一张海阔天空啊！（不过现在龟养大后，纯放养，我的豹会自己跑到厕所找滩有水的地方自行解决，厉害吧） 当然楼主我是个懒人，能不管的就不管了，其实什么垫材只要龟龟适应就行，这里比较不推荐的就有 树皮，还有粟米沙 ，前者容易产生粉尘，而且空气潮湿的时候容易滋生细菌；后者容易被贪吃的龟误食。生长纹要长个一定得爆生长纹，但是爆了生长纹却不一定会长个。关于训练龟龟的问题如果经常散养，训练龟龟定点BB是完全可行的，我有成功案例，先让它习惯在有水潮湿的地方BB，然后慢慢让其BB时熟悉厕所环境，久而久之一定行。","updated":"2023-01-15T02:37:22.886Z","categories":[{"name":"杂记","slug":"杂记","permalink":"https://nnorland.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"花鸟虫鱼","slug":"花鸟虫鱼","permalink":"https://nnorland.github.io/tags/%E8%8A%B1%E9%B8%9F%E8%99%AB%E9%B1%BC/"},{"name":"陆龟","slug":"陆龟","permalink":"https://nnorland.github.io/tags/%E9%99%86%E9%BE%9F/"}]},{"title":"Web移动端Fixed布局的解决方案","date":"2016-08-22T06:32:57.000Z","path":"2016/08/22/FrontEnd/ios-web-fixed-input-bug/","text":"转载自:http://efe.baidu.com/blog/mobile-fixed-layout/移动端业务开发，iOS 下经常会有 fixed 元素和输入框(input 元素)同时存在的情况。 但是 fixed 元素在有软键盘唤起的情况下，会出现许多莫名其妙的问题。 这篇文章里就提供一个简单的有输入框情况下的 fixed 布局方案。iOS下的 Fixed + Input BUG现象软键盘唤起后，页面的 fixed 元素将失效（即无法浮动，也可以理解为变成了 absolute 定位），所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。这便是 iOS 上 fixed 元素和输入框的 bug 。其中不仅限于 type=text 的输入框，凡是软键盘（比如时间日期选择、select 选择等等）被唤起，都会遇到同样地问题。解决思路既然在 iOS 下由于软键盘唤出后，页面 fixed 元素会失效，导致跟随页面一起滚动，那么假如——页面不会过长出现滚动，那么即便 fixed 元素失效，也无法跟随页面滚动，也就不会出现上面的问题了。那么按照这个思路，如果使 fixed 元素的父级不出现滚动，而将原 body 滚动的区域域移到 main 内部，而 header 和 footer 的样式不变，代码如下：12345678910111213141516171819&lt;body class=\"layout-scroll-fixed\"&gt; &lt;!-- fixed定位的头部 --&gt; &lt;header&gt; &lt;/header&gt; &lt;!-- 可以滚动的区域 --&gt; &lt;main&gt; &lt;div class=\"content\"&gt; &lt;!-- 内容在这里... --&gt; &lt;/div&gt; &lt;/main&gt; &lt;!-- fixed定位的底部 --&gt; &lt;footer&gt; &lt;input type=\"text\" placeholder=\"Footer...\"/&gt; &lt;button class=\"submit\"&gt;提交&lt;/button&gt; &lt;/footer&gt;&lt;/body&gt;1234567891011121314151617181920212223242526272829303132header, footer, main &#123; display: block;&#125;header &#123; position: fixed; height: 50px; left: 0; right: 0; top: 0;&#125;footer &#123; position: fixed; height: 34px; left: 0; right: 0; bottom: 0;&#125;main &#123; /* main绝对定位，进行内部滚动 */ position: absolute; top: 50px; bottom: 34px; /* 使之可以滚动 ,用auto而不用scroll可以保证PC浏览的时候,没有滚动时,不出现15像素的空白滚动条*/ overflow-y: auto;&#125;main .content &#123; height: 2000px;&#125;在原始输入法下， fixed 元素可以定位在页面的正确位置。滚动页面时，由于滚动的是 main 内部的 div，因此 footer 没有跟随页面滚动。上面貌似解决了问题，但是如果在手机上实际测试一下，会发现 main 元素内的滚动非常不流畅，滑动的手指松开后，滚动立刻停止，失去了原本的流畅滚动特性。百度一下弹性滚动的问题，发现在 webkit 中，下面的属性可以恢复弹性滚动。-webkit-overflow-scrolling: touch;在 main 元素上加上该属性，嗯，丝般顺滑的感觉又回来了！12345678910main &#123; /* main绝对定位，进行内部滚动 */ position: absolute; top: 50px; bottom: 34px; /* 使之可以滚动 */ overflow-y: scroll; /* 增加该属性，可以增加弹性 */ -webkit-overflow-scrolling: touch;&#125;另外，这里的 header 和 footer 使用的是 fixed 定位，如果考虑到更老一些的 iOS 系统不支持 fixed 元素，完全可以把 fixed 替换成 absolute 。测试后效果是一样的。至此一个不依赖第三方库的 fixed 布局就完成了。Android 下布局谈到了 iOS ，也来简单说一下 Android 下的布局吧。在 Android2.3+ 中，因为不支持 overflow-scrolling ，因此部分浏览器内滚动会有不流畅的卡顿。但是目前发现在 body 上的滚动还是很流畅的，因此使用第一种在 iOS 出现问题的 fixed 定位的布局就可以了。如果需要考虑 Android2.3 以下系统，因为不支持 fixed 元素，所以依然要需要考虑使用 isScroll.js 来实现内部滚动。其实在 fixed 和输入框的问题上，基本思路就是： &gt; 由于 fixed 在软键盘唤起后会失效，导致在页面可以滚动时，会跟随页面一起滚动。因此如果页面无法滚动，那么 fixed 元素即使失效，也不会滚动，也就不会出现 bug 了。所以可以在这个方面去考虑解决问题。其他的一些细节处理在细节处理上，其实还有很多要注意的，挑几个实际遇到比较大的问题来说一下：有时候输入框 focus 以后，会出现软键盘遮挡输入框的情况，这时候可以尝试 input 元素的 scrollIntoView 进行修复。在 iOS 下使用第三方输入法时，输入法在唤起经常会盖住输入框，只有在输入了一条文字后，输入框才会浮出。目前也不知道有什么好的办法能让唤起输入框时正确显示。这暂时算是 iOS 下的一个坑吧。有些第三方浏览器底部的工具栏是浮在页面之上的，因此底部 fixed 定位会被工具栏遮挡。解决办法也比较简单粗暴——适配不同的浏览器，调整 fixed 元素距离底部的距离。最好将 header 和 footer 元素的 touchmove 事件禁止，以防止滚动在上面触发了部分浏览器全屏模式切换，而导致顶部地址栏和底部工具栏遮挡住 header 和 footer 元素。在页面滚动到上下边缘的时候，如果继续拖拽会将整个 View 一起拖拽走，导致页面的“露底”。为了防止页面露底，可以在页面拖拽到边缘的时候，通过判断拖拽方向以及是否为边缘来阻止 touchmove 事件，防止页面继续拖拽。以上面内滚动 layout-scroll-fixed 布局为例，给出一段代码作为参考：12345678910111213141516171819202122232425262728293031323334// 防止内容区域滚到底后引起页面整体的滚动var content = document.querySelector('main');var startY;content.addEventListener('touchstart', function (e) &#123; startY = e.touches[0].clientY;&#125;);content.addEventListener('touchmove', function (e) &#123; // 高位表示向上滚动 // 底位表示向下滚动 // 1容许 0禁止 var status = '11'; var ele = this; var currentY = e.touches[0].clientY; if (ele.scrollTop === 0) &#123; // 如果内容小于容器则同时禁止上下滚动 status = ele.offsetHeight &gt;= ele.scrollHeight ? '00' : '01'; &#125; else if (ele.scrollTop + ele.offsetHeight &gt;= ele.scrollHeight) &#123; // 已经滚到底部了只能向上滚动 status = '10'; &#125; if (status != '11') &#123; // 判断当前的滚动方向 var direction = currentY - startY &gt; 0 ? '10' : '01'; // 操作方向和当前允许状态求与运算，运算结果为0，就说明不允许该方向滚动，则禁止默认事件，阻止滚动 if (!(parseInt(status, 2) &amp; parseInt(direction, 2))) &#123; stopEvent(e); &#125; &#125;&#125;);","updated":"2023-01-15T02:37:22.878Z","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://nnorland.github.io/categories/FrontEnd/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://nnorland.github.io/tags/CSS/"},{"name":"html","slug":"html","permalink":"https://nnorland.github.io/tags/html/"},{"name":"移动开发","slug":"移动开发","permalink":"https://nnorland.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"碗莲种植经验","date":"2016-08-19T14:01:36.000Z","path":"2016/08/19/杂记/nelumbo-nucifera-plated/","text":"碗莲也称为钵莲、盆莲，就是种在碗内的莲花，专供陈于室内几桌之上，以美化居住环境。(其实就是莲花，也叫芙蓉，白莲，→_→)碗莲四季皆可播种，只要水温保存在16°C就可以了。养殖碗莲要领播种时间：莲子无休眠期，只要水温能保持在16℃以上，四季均可播种。莲子在温度、光照适宜的条件下，从播种到开花春季需要50-60天，秋季需要60-80天。种子处理：莲子外壳坚硬密实，浸种前必须进行人工破口，莲子的一头有小突尖，另一头有小凹点。把有小凹点的的那一端在粗糙的水泥地上磨破或用老虎钳子夹破一小口，注意不要夹伤种胚，也不要去壳。需要处理的碗莲种子![处理过的碗莲种子]( http://oss.liujiaan.top/image/hexo/2016/08/wanlian%20%286%29.png)处理碗莲种子浸种催芽：夏季水温20℃-30℃很适合莲子发芽，视种子多少用碗或盆盛水，以浸泡住种子为度。摆放在室内室外亦可，每天换三次水，最好是温水，1周内可以发芽。出芽后放在向阳处，加强光照，不可缺水。待根系形成便可入泥。形成根系入泥：选一个无底孔陶盆或塑料花盆，盆内加半盆田园土或无化工污染的河塘泥，提前两周加水浸泡，不要施肥。移栽时将小荷苗的细根按入泥中，每盆栽一株，移栽后加适量水，以水不淹没小荷叶为度。可以从水族店买一点沙子，把沙子一点点撒进去，铺在泥巴上。沙子分几次撒的。撒一遍，等水沉淀了再撒一遍，直到整个缸都撒均匀。有了沙子后，水很快就清了。再把水换了，还可以在里面养几条小鱼，鱼可以吃水里的虫子，粪便可以肥花，又可以观赏，一举数得。秋冬管理：碗莲种藕娇嫩易受冻害，遇低温来时应放到0—5度的地方保存。冬季是碗莲的休眠期，不需要光合作用可加深水位安全过冬。待到来年清明前后翻盆取出莲藕重新栽植即可。参考：碗莲的种植方法图解-夏夏园艺种植过程记录哈哈，发芽了","updated":"2023-01-15T02:37:22.885Z","categories":[{"name":"杂记","slug":"杂记","permalink":"https://nnorland.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"花鸟虫鱼","slug":"花鸟虫鱼","permalink":"https://nnorland.github.io/tags/%E8%8A%B1%E9%B8%9F%E8%99%AB%E9%B1%BC/"}]},{"title":"swig模板引擎","date":"2016-08-19T09:30:53.000Z","path":"2016/08/19/JavaScript/node-js-swig-engine/","text":"现在有很多视图引擎,jade,swig等.用过jade,感觉不是很喜欢.还是.html看起来舒服一点.swig能很好的解决这一点,swig默认以.ejs文件结尾,但是能通过一些设置,让它更加友好.首先附上github地址:swig.js目前没有发现swig的文档,github.io貌似挂了.可以将项目clone下来,执行12$ npm install swig$ make docs编译完成自动打开浏览器,然后能看到documentation.要在express框架中用swig需要进行一些设置.12345678// view engine setupapp.engine('html', swig.renderFile)app.set('view cache', false);swig.setDefaults(&#123; cache: false &#125;);app.set('views', path.join(__dirname, 'views'));app.set('view engine', 'html');// Open and close controls for variables. Defaults to ['&#123;&#123;', '&#125;&#125;'].swig.setDefaults(&#123;varControls: ['&lt;%=', '%&gt;']&#125;);补充:这里有一个模板引擎性能的测试,不知道有没有参考价值(测试模板较少,包括[artTemplate; jCT; juicer; doT; Handlebars; tmpl; easyTemplate; underscoreTemplate; baiduTemplate; Mustache; kissyTemplate;])引擎渲染速度测试","updated":"2023-01-15T02:37:22.881Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://nnorland.github.io/tags/html/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://nnorland.github.io/tags/Nodejs/"}]},{"title":"CSS小技巧整理","date":"2016-08-18T07:36:09.000Z","path":"2016/08/18/FrontEnd/css-skill/","text":"CSS小技巧整理某一元素高度等于宽度示例:123456789101112131415&lt;style type=\"text/css\"&gt;#container &#123; width: 80%; height: 500px;&#125;.attr &#123; width: 50%; height: 0; padding-bottom: 50%; background-color: #008b57;&#125;&lt;/style&gt;&lt;div id='container'&gt; &lt;div class='attr'&gt;&lt;/div&gt;&lt;/div&gt;来源: css中如何规定某一元素高度等于其宽度iOS textarea,默认样式,字体颜色,目前未知.最好不用,采用divblur 边缘发亮,可以将blur元素超过所需大小,多余部分overflow:hidden掉.12345.blur&#123; filter: blur(10px); margin: -10px; padding: 10px;&#125;css中padding和margin,设置宽高,百分比是相对父元素的宽度.可以用来生成等比矩形.浏览器默认样式中,ol,ul,li的padding-left为像素单位,其他padding是以em为单位,不覆盖样式需要注意.","updated":"2023-01-15T02:37:22.876Z","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://nnorland.github.io/categories/FrontEnd/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://nnorland.github.io/tags/CSS/"}]},{"title":"Mac软件","date":"2016-08-17T09:07:29.000Z","path":"2016/08/17/mac-software/","text":"aria2uninstallpkgcheat sheet //快捷键提示工具AppCleaner //应用卸载清理scroll reverser //鼠标触摸板不同滚动方向epubee // 电子书下载脱壳calibre //电子书管理dash //Mac独有的文档查看工具,推荐core Patcher //macOS Sierra10.12下CORE Keygen系列注册机修复工具Alternote //Mac下印象笔记第三方工具paste //Mac剪贴板增强Clipy // 开源剪贴板历史小工具Alfred //workflow很强大shadowshocksXClearviewiPicCalcbot //替代Mac自带计算器,CharlesParalles Desktop //虚拟机WeChatPlugin-MacOS // 防撤回//开发必备docker , webstorm , ps ,sketch , youdaoDict ,firefoxDeveloperEdition, iterm2 ,sublime ,VS code,oh-my-zsh,homebrew,virtualBox,neatestMusic","updated":"2023-01-15T02:37:22.884Z","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://nnorland.github.io/tags/Mac/"}]},{"title":"Give it five minutes","date":"2016-08-17T07:11:44.000Z","path":"2016/08/17/杂记/give-it-five-minutes/","text":"转载自https://signalvnoise.com/posts/3124-give-it-five-minutes原文A few years ago I used to be a hothead. Whenever anyone said anything, I’d think of a way to disagree. I’d push back hard if something didn’t fit my world-view.It’s like I had to be first with an opinion – as if being first meant something. But what it really meant was that I wasn’t thinking hard enough about the problem. The faster you react, the less you think. Not always, but often.It’s easy to talk about knee jerk reactions as if they are things that only other people have. You have them too. If your neighbor isn’t immune, neither are you.This came to a head back in 2007. I was speaking at the Business Innovation Factory conference in Providence, RI. So was Richard Saul Wurman. After my talk Richard came up to introduce himself and compliment my talk. That was very generous of him. He certainly didn’t have to do that.And what did I do? I pushed back at him about the talk he gave. While he was making his points on stage, I was taking an inventory of the things I didn’t agree with. And when presented with an opportunity to speak with him, I quickly pushed back at some of his ideas. I must have seemed like such an asshole.His response changed my life. It was a simple thing. He said “Man, give it five minutes.” I asked him what he meant by that? He said, it’s fine to disagree, it’s fine to push back, it’s great to have strong opinions and beliefs, but give my ideas some time to set in before you’re sure you want to argue against them. “Five minutes” represented “think”, not react. He was totally right. I came into the discussion looking to prove something, not learn something.This was a big moment for me.Richard has spent his career thinking about these problems. He’s given it 30 years. And I gave it just a few minutes. Now, certainly he can be wrong and I could be right, but it’s better to think deeply about something first before being so certain you’re right.There’s also a difference between asking questions and pushing back. Pushing back means you already think you know. Asking questions means you want to know. Ask more questions.Learning to think first rather than react quick is a life long pursuit. It’s tough. I still get hot sometimes when I shouldn’t. But I’m really enjoying all the benefits of getting better.If you aren’t sure why this is important, think about this quote from Jonathan Ive regarding Steve Jobs’ reverence for ideas:And just as Steve loved ideas, and loved making stuff, he treated the process of creativity with a rare and a wonderful reverence. You see, I think he better than anyone understood that while ideas ultimately can be so powerful, they begin as fragile, barely formed thoughts, so easily missed, so easily compromised, so easily just squished.That’s deep. Ideas are fragile. They often start powerless. They’re barely there, so easy to ignore or skip or miss.There are two things in this world that take no skill: 1. Spending other people’s money and 2. Dismissing an idea.Dismissing an idea is so easy because it doesn’t involve any work. You can scoff at it. You can ignore it. You can puff some smoke at it. That’s easy. The hard thing to do is protect it, think about it, let it marinate, explore it, riff on it, and try it. The right idea could start out life as the wrong idea.So next time you hear something, or someone, talk about an idea, pitch an idea, or suggest an idea, give it five minutes. Think about it a little bit before pushing back, before saying it’s too hard or it’s too much work. Those things may be true, but there may be another truth in there too: It may be worth it.译文几年前，我还是一个非常容易冲动的人。无论何人何时谈论何事，我总会想着去反驳。如果某事不符合我的世界观我会狠狠地拒绝。就好象我必须是这个观念的发现者（第一人），因为是第一个才会有意义。但是真实的情况是，有关那些问题我并没有思考的够深。你反应的越快，你思考的越少。并不总是这样，但通常会是。谈论膝跳反射很容易，因为它们是只有人类才有的反应。你也有。如果你的邻居不是该反射的免疫者，你也不应当是。时间返回到2007年。那时候我在RI省举行商业创新工厂的会议上谈话。Richard Saul Wurman也在。我谈完后Richard过来自我介绍并恭维我的谈话。他很宽容大量，他本不必那样做的。我是怎么回应的呢？我反驳了他的谈话。当他在大会上阐述自己观点的时候，我列了一份我不同意事情的单子。当有机会与他说话的时候，我很快地反驳了他的一些想法。我一定看起来是非常的可恶。他的举动改变了我的生活。事情很简单。他说，老兄给我五分钟时间。我想问他这是啥意思。他说，可以不同意，可以反驳，可以有强大的信念和信仰，但在你想争论这些想法之前请不妨思考它们几分钟。五分钟代表思考，绝非反应。他绝对是正确的。我开始以讨论的观点去证明某些事情，而不是学习它们。对我来说，那确实一个伟大的瞬间。Richard花了毕生去思考那些问题，对于它们，他奉献了30年，我却只给了几分钟时间而已。现在，当然他可以是错误的我可以是正确的，但最好还是先好好思考那些问题在你确信你是对的之前。提问题和反驳是有区别的，反驳意味着已经认为你知道了；问问题意味着你想知道。问更多问题吧。遇事先思考而不是快速反驳是值得一生追求的信条。我知道这很难。我时而还是会头脑发热，当我不再总是头脑发热时，我真的享受这种观念带来的好处。如果你还不确定为什么这是重要的，考虑一下Jonathan Ive的这段向Steve Jobs致敬的话。\b\b“正如Steve热爱想法，热爱制造东西，他对创新有着罕见和崇高地尊敬。你知道我认为他比任何人都理解想法最终是强大的，想法刚开始也许很脆弱，几乎算不上想法，所以很容易被忘掉，很容易被妥协，很容易被扯碎”这段话很深刻，想法最初都是脆弱的，他们一开始并没有任何能量，他们算不上是想法，因而很容易被忽略。这世界上有两种事情不需要技巧:1,花别人的钱;2,摒弃想法。摒弃想法非常容易它不需要涉及任何努力。你可以嘲笑它，可以忽略它，可以朝它喷烟圈，这都容易。难的是保护它，思考它，浸淫它，探索它，重复它，实验它。正确的想法会开启我们的生活，一如错误的想法一样。所以，下一次你听到某件事情的时候，或者某个人谈论某个想法，抛出或者建议一个想法的时候，给这个想法五分钟。在反驳它之前稍微思考一下，而不是说思考很难做或者很费工夫。也许真的很难，但是也可能有另外一个事实：思考是值的。","updated":"2023-01-15T02:37:22.885Z","categories":[{"name":"杂记","slug":"杂记","permalink":"https://nnorland.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://nnorland.github.io/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"移动端高清屏图片适配","date":"2016-08-04T08:48:59.000Z","path":"2016/08/04/FrontEnd/mobile-apter/","text":"参考张鑫旭博客首先我们看下我们切图的命名方式：假设有两张图片名为：正确的命名方式应该是这样test_t@2x.png 、test_t@3x.png这是对于ios APP 切图来说的。HTML并不会智能匹配,但是新标准有相应的属性能够实现.1. image-setWebkit内核”safari6”和“chrome21”支持CSS4的background-image新规范草案image-set。通过Webkit内核的浏览器私有属性“-webkit”，image-set为Web前端人员提供了一种解决高分辨率图像的显示，用来解决苹果公司提出的Retian屏幕显示图片的技术问题。简而言之：这个属性用来支持Web前端人员解决不同分辨率下图片的显示，特别的（Retina屏幕）。测试页面1&lt;div id=\"test\"&gt;&lt;/div&gt;12345678910111213#test &#123; background-image: url(assets/no-image-set.png); background-image: -webkit-image-set(url(assets/test.png) 1x, url(assets/test-hires.png) 2x); background-image: -moz-image-set(url(assets/test.png) 1x, url(assets/test-hires.png) 2x); background-image: -o-image-set(url(assets/test.png) 1x, url(assets/test-hires.png) 2x); background-image: -ms-image-set(url(assets/test.png) 1x, url(assets/test-hires.png) 2x); width:200px; height:75px; &#125;img srcset123&lt;img class=\"image\" src=\"mm-width-128px.jpg\" srcset=\"mm-width-128px.jpg 128w, mm-width-256px.jpg 256w, mm-width-512px.jpg 512w\" sizes=\"(max-width: 360px) 340px, 128px\"&gt;1&lt;img src=\"normal-image.jpg\" srcset=\"better-image.jpg 2x\"&gt;srcset用来指向提供的图片资源，注意，仅仅是资源指向，没有以前的1x, 2x什么的，这个都交给浏览器了，我们不需要关心！例如这里，指向了3个尺寸图片，分别实际尺寸128像素，256像素和512像素。sizes用来表示尺寸临界点，主要跟响应式布局打交道。语法如下：sizes=”[media query] [length], [media query] [length] … etc”例如上述代码中，size = “(max-width: 360px) 340px, 128px”表示当视区宽度不大于360像素时候，图片的宽度限制为340像素，其他情况下，使用128像素（对应下面demo页面第1张图）。如果sizes=”128px”, 则尺寸就一直是128像素，图片只会根据设备像素比发生变化。注意，这里所有的值都是指宽度值，且单位任意，em, px, cm, vw, …都是可以的，甚至可以CSS3的calc计算（对应下面demo页面第2张图），例如：sizes=”(max-width: 360px) calc(100vw - 20px), 128px”表示当视区宽度不大于360像素时候，图片宽度为整个视区宽度减去20像素的大小。","updated":"2023-01-15T02:37:22.878Z","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://nnorland.github.io/categories/FrontEnd/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://nnorland.github.io/tags/CSS/"},{"name":"html","slug":"html","permalink":"https://nnorland.github.io/tags/html/"},{"name":"移动开发","slug":"移动开发","permalink":"https://nnorland.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"yoeman-generator各种构造器,轮子","date":"2016-08-01T08:33:45.000Z","path":"2016/08/01/JavaScript/yoeman-generator/","text":"yeoman官网提供了很多构造器,免去了自己构建的烦恼.地址:http://yeoman.io/generators/","updated":"2023-01-15T02:37:22.882Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://nnorland.github.io/tags/Nodejs/"},{"name":"Yeoman","slug":"Yeoman","permalink":"https://nnorland.github.io/tags/Yeoman/"}]},{"title":"div实现高度撑开的输入框","date":"2016-08-01T01:23:22.000Z","path":"2016/08/01/FrontEnd/div-contenteditable/","text":"转载来自张鑫旭-鑫空间-鑫生活原文地址： http://www.zhangxinxu.com/wordpress/2016/01/contenteditable-plaintext-only/contenteditable使用input或textare时,输入框大小固定,因此采用div,在div上增加contenteditable=&quot;true&quot;属性.这样的话,没有placeholder属性,通过css样式:empty:before,增加content解决.下面是一个示例12345&lt;div class=\"test_box\" contenteditable=\"true\" onpaste=\"return false\" data-placeholder=\"聊聊这组照片\" id=\"test_box\" onKeyUp=\"showLen(this);\"&gt;&lt;/div&gt;&lt;div style=\"text-align: right;padding-right: 0.8em\"&gt; &lt;span id=\"str_length\" class=\"str_length\"&gt;0&lt;/span&gt; &lt;span&gt;/200&lt;/span&gt;&lt;/div&gt;12345678910111213141516171819.test_box &#123; min-height: 100px; max-height: 300px; margin-left: auto; margin-right: auto; padding: 0.8em; padding-bottom: 0; outline: 0; word-wrap: break-word; overflow-x: hidden; overflow-y: auto;&#125;.test_box:empty:before &#123; content: attr(data-placeholder); color:#d3d3d3;&#125;.test_box:focus:before&#123; content:none;&#125;12345678910111213141516&lt;script&gt; showLen(document.getElementById(\"test_box\")); function showLen(obj) &#123; var t = document.getElementById(\"test_box\").innerText; var num = document.getElementById('str_length') if (t.length &gt; 200) &#123; num.innerHTML = obj.innerText.length; num.style.color= \"red\"; return false; &#125; else &#123; num.innerHTML = obj.innerText.length; return true; &#125; &#125;&lt;/script&gt;注意,在获取div的内容时,不能用value,用innerText温故知新2016-08-25补充利用全浏览器都支持的contenteditable模拟文本域可以实现体验相当不错的高度跟随内容自动撑开的效果，但是呢，有个很大的问题就是HTML内容可以直接被粘贴进去.提问：在HTML中，contenteditable支持的属性值是？图样图森破时候的我，脑中就只有contenteditable=”true”和contenteditable=”false”，咳咳，后来我发现自己太天真了，新的草案中明确表示还有多个其他属性值：The contenteditable attribute is an enumerated attribute whose keywords are the empty string (“”), “events”, “caret”, “typing”, “plaintext-only”, “true”, and “false”. There is one additional state, the inherit state, which is the missing value default (and the invalid value default).垂直展示下就是（不包括默认的inherit继承）：123456contenteditable=\"\"contenteditable=\"events\"contenteditable=\"caret\"contenteditable=\"plaintext-only\"contenteditable=\"true\"contenteditable=\"false\"别问我，我也不知道”events”和”caret”是干什么用的，嘿，但是”plaintext-only”我是知道的，可以让编辑区域只能键入纯文本。这里就不需要demo了，直接下面的框框，大家可以试试，看看能不能搞富文本。&lt;div contenteditable=&quot;plaintext-only&quot;&gt;&lt;/div&gt;与contenteditable属性无关的CSS控制法一个div元素，要让其可编辑，也就是可读写，contenteditable属性是最常用方法，做前端的基本上都知道。但是，知道CSS中有属性可以让普通元素可读写的的同学怕是就少多了。主角亮相：user-modify.支持属性值如下：1234user-modify: read-only;user-modify: read-write;user-modify: write-only;user-modify: read-write-plaintext-only;其中，write-only不用在意，当下这个年代，基本上没有浏览器支持，以后估计也不会有。read-only表示只读，就是普通元素的默认状态啦。然后，read-write和read-write-plaintext-only会让元素表现得像个文本域一样，可以focus以及输入内容。会发现，设置了read-write和read-write-plaintext-only值的两个标签元素是可以被focus的.而这两者的区别就在于，一个可以输入富文本，而下面一个只能输入纯文本.然而，抱歉地跟大家讲下，目前只有webkit内核浏览器才支持read-write-plaintext-only这个值，因此，我们的使用其实是：1-webkit-user-modify: read-write-plaintext-only我们可以在移动端使用，以及，只需要兼顾webkit内容的桌面网页项目。","updated":"2016-08-25T03:21:00.000Z","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://nnorland.github.io/categories/FrontEnd/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://nnorland.github.io/tags/CSS/"},{"name":"html","slug":"html","permalink":"https://nnorland.github.io/tags/html/"}]},{"title":"git commit message和change log编写指南","date":"2016-07-26T03:28:53.000Z","path":"2016/07/26/git-commit-message-change-log/","text":"原作者：阮一峰日期：2016年1月6日原帖地址:Commit message 和 Change log 编写指南git每次提交代码，都要写commit message，否则不允许提交。1$ git commit -m &quot;hello world&quot;只执行git commit，会跳出文本编辑器，让你写多行。基本上你写什么都行但是,一般来说,commit message应该清晰明了.说明本次提交的目的.目前,社区有很多种commit message 规范.本文介绍angular规范,这是目前最广泛的写法,比较合理和系统化,并且有配套的工具.commit message 的作用格式化commit message 有几个好处.提供更多的历史信息,方便浏览.比如,下面的命令显示上次发布之后的变动,每个commit占据一行,你只要看首行,就知道某次commit的目的.$ git logHEAD –pretty=formate:%shttp://oss.liujiaan.top/image/hexo/2016/07/26/bg2016010604.png可以过滤某些commit(比如文档改动),以便于快速查找信息.比如,下面的命令仅显示本次发布新增加的功能.$ git logHEAD –grep feature可以直接从commit生成change log.change log 是发布新版本时,用来说明与上一个文档差异的文档.commit message 的格式每次提交,commit message 都包括三个部分:header,body和footer.12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&#x2F;&#x2F; 空一行&lt;body&gt;&#x2F;&#x2F; 空一行&lt;footer&gt;headerheader部分只有一行,包括三个字段:type(必需),scope(可选)和subject(必需).type用于说明commit的类别,只允许使用下面7个标识.1234567feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。scopescope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。subjectsubject是 commit 目的的简短描述，不超过50个字符。以动词开头，使用第一人称现在时，比如change，而不是changed或changes第一个字母小写结尾不加句号（.）bodyBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。1234567More detailed explanatory text, if necessary. Wrap it toabout 72 characters or so.Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent有两个注意点。使用第一人称现在时，比如使用change而不是changed或changes。应该说明代码变动的动机，以及与以前行为的对比。footerFooter 部分只用于两种情况。不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。1234567891011121314151617BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: &#123; myAttr: &#39;attribute&#39;, &#125; After: scope: &#123; myAttr: &#39;@&#39;, &#125; The removed &#96;inject&#96; wasn&#39;t generaly useful for directives so there should be no code using it.关闭 Issue如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。1Closes #234也可以一次关闭多个 issue 。1Closes #123, #245, #992Revert还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。123revert: feat(pencil): add &#39;graphiteWidth&#39; optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02.Body部分的格式是固定的，必须写成This reverts commit &amp;lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。CommitizenCommitizen是一个撰写合格 Commit message 的工具。安装命令如下。$ npm install -g commitizen然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。$ commitizen init cz-conventional-changelog –save –save-exact以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。生成change log如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成（例1，例2，例3）。生成的文档包括以下三个部分。123New featuresBug fixesBreaking changes.每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。$ npm install -g conventional-changelog$ cd my-project$ conventional-changelog -p angular -i CHANGELOG.md -w上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。如果你想生成所有发布的 Change log，要改为运行下面的命令。$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0为了方便使用，可以将其写入package.json的scripts字段。12345&#123; &quot;scripts&quot;: &#123; &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot; &#125;&#125;以后，直接运行下面的命令即可。$ npm run changelog","updated":"2023-01-15T02:37:22.883Z","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://nnorland.github.io/tags/Git/"}]},{"title":"Java问题记录","date":"2016-07-12T12:33:05.000Z","path":"2016/07/12/icstest-java/","text":"引言Java问题记录前端开发怎么能不懂点后台知识？说好的前(全)端(栈)工程师呢？八种基本数据类型经常忘…byte ,short ,init ,longchar ,boolean ,float ,doublestring,stringbuffer与stringbuilder的区别?1.在执行速度方面的比较：StringBuilder &gt; StringBuffer2.StringBuffer与StringBuilder，他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，不像String一样创建一些对象进行操作，所以速度就快了。3.StringBuilder：线程非安全的 StringBuffer：线程安全的我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的，就是速度的原因。对于三者使用的总结：如果要操作少量的数据用 = String单线程操作字符串缓冲区 下操作大量数据 = StringBuilder多线程操作字符串缓冲区 下操作大量数据 = StringBufferJava防止非法和重复表单提交的方法答: 使用Session技术:在regist.jsp页面中生成一个唯一随机值, 将其保存到Session中, 同时将其保存为表单的隐藏域的值在处理注册的请求时,获取Session中值,获取请求参数的值,比较两者是否相同, 如果相同说明不是重复提交,请求通过同时删除session中保存的值, 如果不相同则是重复提交, 不能通过.经典现实案例:一位乘客在北京火车站买了一张去天津的火车票(直接刷的那种),他刷票进站坐火车去了天津, 回来后过了几天, 他又需要去天津这次他不想再买票, 直接拿上次的票去进站口刷, 检票机提示“此火车票已使用过了”, 不能进站.博客园详细文章解答:JavaWeb学习总结(十三)——使用Session防止表单重复提交静态include与动态include的区别分析：为了更深刻的了解这两者的区别，专门搜索了类似的资料，写出来供大家分享：静态include的结果是把其他jsp引入当前jsp,两者合为一体，用include指令, 包含的动作是在jsp被编译成java文件时执行的, 只有第一次请求时执行.动态include的结构是两者独立,直到输出时才合并，用&lt;jsp:include&gt;, 包含的动作是在jsp对应的Serlet处理请求时去执行的,每次请求都会执行.动态include的jsp文件独立性很强,是一个单独的jsp文件,需要使用的对象,页面设置,都必须由自己创建,当然,还好它和include它的页面的request范围是一致的.而静态include纯粹是把代码写在外面的一种共享方法,所有的变量都是可以和include它的主文件共享,两者高度紧密结合,不能有变量同名的冲突.而页面设置也可以借用主文件的.静态include主要是对静态页面的引入，不会检查所包含文件的变化&lt;% @ include file=&quot;include.html&quot; %&gt;动态include主要是对动态页面的引入，它总是会检查所引入的页面的变化，如果所包含的资源在请求间发生变化，则下一次请求包含&lt;jsp:include&gt;动作的jsp时，将包含资源的新内容。另一方面，include指令在转换时一次性地将内容复制到jsp中，如果所包含的资源发生变化，则使用include指令的jsp将不能反应出新的内容，除非重新编译该jsp。&lt;jsp：include&gt;动作包含的属性：page：指定所包含资源的相对url路径，该资源必须时同一web应用程序的组成部分。flush：指定在执行include动作后是否应刷新缓冲区，在jsp1.1中，该属性必须设置为真。使用动态include动作时，根据jsp1.1规范，jsp容器允许判断通过include指令包含的资源是否发生变化。如果发生变化。则容器可以重新编译包含该资源的jsp，然而，该规范并没有提供向容器表明某个包含的资源发生变化的机制。动态include的优点和不足：优点：引入和同步一个动态的页面，使jsp页面更具灵活性能和不同页面之间进行信息的交互和快捷的实现方式。改变了原始的所有页面编码都放在一个jsp上，使不同的功能分别写在不同页里，通过动态include方式引用到页面，更易于编码，更易于管理。不足：动态的引入时需要频繁的变化和页面信息的更新和交互，要占用大量的资源开销。降低页面的访问速度。如果在没必要动态引入的情况下，不要使用动态include应该注意事项：jsp:include动作的flush属性必须要定义，不定义会出现转换错误。而且设置的flush必须要为true在jsp:include动作中指定的页面必须是同一web应用程序的一部分。如果引入的是非同一web应用的页面将导致请求时错误。List,Set,Map是否继承自Collection接口？答：List，Set是，Map不是。如图1234567891011Collection├List &#x2F;&#x2F;有序│ ├LinkedList│ ├ArrayList│ └Vector│ └Stack└Set &#x2F;&#x2F;无序不重复Map &#x2F;&#x2F;键值对├Hashtable├HashMap└WeakHashMapCollection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java JDK不能提供直接继承自Collection的类，Java JDK提供的类都是继承自Collection的”子接口”，如:List和Set。注意：Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当做一组key集合，一组value集合，或者一组key-value映射。详细介绍：List特点：元素有放入顺序，元素可重复Map特点：元素按键值对存储，无放入顺序Set特点：元素无放入顺序，元素不可重复（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的）List接口有三个实现类：LinkedList，ArrayList，VectorLinkedList：底层基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢ArrayList和Vector的区别：ArrayList是非线程安全的，效率高；Vector是基于线程安全的，效率低Set接口有两个实现类：HashSet(底层由HashMap实现)，LinkedHashSetSortedSet接口有一个实现类：TreeSet（底层由平衡二叉树实现）Query接口有一个实现类：LinkListMap接口有三个实现类：HashMap，HashTable，LinkeHashMapHashMap非线程安全，高效，支持null；HashTable线程安全，低效，不支持nullSortedMap有一个实现类：TreeMap其实最主要的是，list是用来处理序列的，而set是用来处理集的。Map是知道的，存储的是键值对set一般无序不重复.map kv 结构 ,list 有序","updated":"2023-01-15T02:37:22.884Z","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://nnorland.github.io/tags/Java/"}]},{"title":"7niu","date":"2016-07-10T05:08:29.000Z","path":"2016/07/10/7niu/","text":"由于hexo博客不能存储图片，需要自己将图片放到图床上，这里推荐7牛的云存储。对个人用户来说基本就是免费的。具体方法，就不说了。这里留坑以后填充使用过程中遇到的坑。","updated":"2023-01-15T02:37:22.875Z","categories":[],"tags":[{"name":"7niu","slug":"7niu","permalink":"https://nnorland.github.io/tags/7niu/"}]},{"title":"JavaScript基础巩固第一天","date":"2016-07-05T06:44:49.000Z","path":"2016/07/05/JavaScript/JavaScript-firstday/","text":"JavaScript组成部分：语法，类型，语句，关键字，保留字，操作符，对象。标识符，就是指变量、函数、属性的名字，或者函数的参数。按照惯例，ECMAScript标识符采用驼峰大小写格式。构造函数都以大写字母开始。JavaScript中的实数常常只是真实值的一个近似表示。有两种方式来访问对象的属性，点操作符或者中括号操作符。JavaScript五种基本数据类型，Undefined,Null,Boolean,Number和string。还有一个复杂数据类型，object。从逻辑角度来看，null值表示一个空指针对象 alert(typeof null); //=&gt; “object”typeof是一个操作符，不是函数。JavaScript是大小写敏感的，因此typeOf完全可以是一个有效的函数名。如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值，这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，如if (car !=null) { /* 对car对象执行某些操作*/ }实际上，undefined值是派生自null的，因此alert(null == undefined); //true引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。当然，如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。如下所示：1234567function add(num1, num2) &#123; var sum = num1 + num2; return sum;&#125;var result = add(10, 20); //30alert(sum); //由于sum不是有效的变量，因此会导致错误在初始化变量之前，一定要先声明。在严格模式下，初始化未经声明的变量会导致错误。在for循环中,这点尤其重要12345for (var i=0; i &lt; 10; i++)&#123; doSomething(i);&#125;alert(i); //10","updated":"2023-01-15T02:37:22.879Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nnorland.github.io/tags/JavaScript/"}]},{"title":"markdown介绍及语法","date":"2016-07-02T10:34:22.000Z","path":"2016/07/02/markdown-guide/","text":"Markdown简介Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。—— 维基百科正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。文档创始人 John Gruber 的 Markdown 语法说明马克飞象帮助文档markdown中文语法说明好用的markdown工具安卓端推荐markdownX或者JotterPadX。前者专用于markdown的编写，能够预览。后者是一个强大的文本编辑器，目前没有发现能够markdown文件。Mac推荐MOU。小巧强大的markdown文本编辑器。Windows 也有很多优秀的markdown编辑器，这里不一一列举，本人用atom，github出品的文本编辑器，打开速度堪比IDE，这点不能和sublime相比，但是git标识和markdown方面，sublime表现不如atom，尤其是git，我习惯于能辨识出哪些文件、段落进行了修改，sublime并不能做到。这里安利一个atom小插件，可能大家都见过， –activate-power-mode偶尔装装逼就好，瞎了不要找我activate-power-mode常见语法标题标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。12345# 一级标题## 二级标题### 三级标题以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。列表在文字前加上 - 或 * 为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。abcabc引用如果你需要引用一小段别处的句子，那么就要用引用的格式。例如这样只需要在文本前加入 &gt; 大于号即可图片与链接插入链接与插入图片的语法很像，区别在一个 !号图片为：链接为：文字–显示粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。例如：这里是粗体 这里是斜体分割线分割线的语法只需要三个 * 或 - 号，例如：删除线删除线高亮代码块12345&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;制作一份待办事宜 Todo 列表 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能表格ItemValueQtyComputer1600 USD5Phone12 USD12Pipe1 USD234","updated":"2023-01-15T02:37:22.884Z","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://nnorland.github.io/tags/Markdown/"},{"name":"Wiki","slug":"Wiki","permalink":"https://nnorland.github.io/tags/Wiki/"}]},{"title":"hexo第一天","date":"2016-07-02T06:44:49.000Z","path":"2016/07/02/hello-world/","text":"今天利用coding的webIDE搭建了hexo博客。回来记录一下。前言 之前也在github上用过hexo搭建博客，一直感觉挺好的，除了有一个问题——搭建写作环境。由于Hexo是基于Node.js的，所以需要在本地电脑上安装Node.js，然后再安装Hexo，还得安装Git，一步步配置环境，有点繁琐。所以很明显存在一个问题——重装电脑后，又要配置环境，或者不能在任意一终端进行写作。现在终于找到一个方法可以实现“Set up once, write everywhere”。这就是Coding.net的WebIDE。coding的webIDE出来时间不是很长，成熟度不如koding和c9，但是胜在访问速度快。。。毕竟是国内的服务器。coding webIDE使用不当的话，偶尔会出现一些问题，比如打不开等情况，可以点击反馈，让coding的官方人员帮你解决。2016.08.26补充coding时不时有很多问题,已放弃webIDE,回归github.将博客代码存放在hexo分支.首先附上两篇搭建hexo博客的通用文档文档 | HexoHexo静态博客使用指南一、准备工作首先，去Coding.net官网注册一个账号，接着，点击“+ 创建项目”,创建一个新项目。如下图所示：项目名称和简介随意项目类型选择“私有”勾选“使用README.md初始化项目”http://oss.liujiaan.top/image/hexo/2016/07/1%20%285%29.png创建好项目后，通过导航栏到IDE界面，点击新建工作空间http://oss.liujiaan.top/image/hexo/2016/07/1%20%286%29.png随后，单击“同步仓库”，等待同步仓库完成。http://oss.liujiaan.top/image/hexo/2016/07/1%20%287%29.png接着，点开我们刚刚创建的项目。会提示配置界面。webIDE是收费的，收取coding的虚拟货币–码币。但是收费很良心，而且有各种途径能够赚取。用来写博客的话，选最低配置就可以。基本上和免费差不多。http://oss.liujiaan.top/image/hexo/2016/07/1%20%284%29.pnghttp://oss.liujiaan.top/image/hexo/2016/07/1%20%281%29.png如何获取码币回到主题，创建完webIDE，点击打开，等待webIDE载入完成。就能看到界面了。全屏正有种带GUI的Linux的既视感~~而且terminal默认安装好了zsh和oh-my-zsh，算是附带小惊喜吧。调整一下选项。http://oss.liujiaan.top/image/hexo/2016/07/1%20%283%29.png有没有超酷！装逼利器，而且巨方便。Hexo是基于Nodejs的，所以我们将运行环境切换为Nodejs。http://oss.liujiaan.top/image/hexo/2016/07/1%20%282%29.png二、正式开始打开高大上的终端，安装hexo，输入sudo npm install -g hexo-cli等待安装完成。然后使用hexo init命令初始化博客sudo hexo init正常情况下，到这里hexo就安装完成了，如果出错的话，根据命令行提示进行处理。然后，我们首先先解锁一下配置文件（将所有文件提权至777）sudo chmod -R 777 *打开_config.yml博客配置文件，编辑title等属性，保存。注意将设置语言。language: zh-Hans支持多语言的主题会根据博客语言设置进行显示。然后开启我们的hexo进行预览一下。hexo s然后，我们就可以通过单击右上角的访问链接，将端口设置为4000来访问网站。这里用的是缩写，hexo命令如下12345hexo n &quot;我的博客&quot; &#x3D;&#x3D; hexo new &quot;我的博客&quot; #新建文章hexo p &#x3D;&#x3D; hexo publishhexo g &#x3D;&#x3D; hexo generate#生成hexo s &#x3D;&#x3D; hexo server #启动服务预览hexo d &#x3D;&#x3D; hexo deploy#部署测试成功了，那么我们先在终端中按Ctrl+C退出，然后按下访问链接中的垃圾桶来销毁端口。那么大家刚才也看到了，IDE中的访问链接是测试用途，长且有时间限制，一看就非常不严谨，所以，我们要学会把博客Push到托管平台中。那么，首先，我们先要安装Hexo Git插件以至于可以将静态页推送到托管平台上。sudo npm install hexo-deployer-git –save安装完成之后，我们配置一下_config.yml文件。修改一下最下面的deploy：将12deploy: type:修改为12345deploy: type: git repo: [仓库地址]branch: mastermessage: blog update #push message注：仓库地址可以在您的项目主页找到。将博客推送到代码托管平台，在终端中使用：sudo hexo g -d如果是http的仓库地址，会提示输入用户名和密码。ssh模式，我没有成功，提示没有权限不知道是不是因为私人仓库的原因。我们返回coding仓库，能看到代码已经推送到仓库中了。下面，我们开启静态页服务（Pages）。只需要单击页面上的“Pages服务”，设置部署分支为master，然后单击“立即开启”，即可访问！三、添加、删除、编辑文章1、创建文章打开终端，以如下格式敲入命令：sudo hexo new &lt;文章名称&gt;这样，我们就创建了一篇文章。可以在目录source-&gt;_posts中找到并编辑。完成后部署代码即可看到新的文章。sudo hexo g -d如果不想博文在首页全部显示, 并能出现阅读全文按钮效果, 需要在你想在首页显示的部分下添加&lt;!--more--&gt;123此处及以上的内容会在首页显示&lt;!--more--&gt;以下是在首页隐藏的部分2、删除文章只需删除source/_posts目录下的相应md文件，重新部署即可。部署之前最好，清空一下hexo缓存，不然可能不会生效。hexo clean3、编辑文章编辑文章和删除道理相同，修改相应md文件重新部署即可。四、将hexo代码同步到hexo分支。虽然我们有webIDE，能随时写博客，不受hexo环境的限制，但是还是最好将hexo的源码同步到代码仓库。由于默认deploy的是master分支。我们可以新建一个hexo分支gco -b hexo将代码我们博客的原始代码push到分支中，双重保险，也方便在本地修改代码。webIDE只是多了一个更加方便的选择。gaagcmsg “hexo”gp origin hexo这样，在我们的master分支是我们的博客内容，hexo分支是我们的博客源码。非常方便。五、hexo主题由于hexo默认的主题，并不是很符合部分人的审美，hexo提供了很多主题，也可以自己编写主题文件。自己动手写主题文件就不说了。说一下更换主题。官方提供了一个wiki地址，里面有很多主题。hexo主题wiki：https://github.com/hexojs/hexo/wiki/ThemesHexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为 站点配置文件，后者称为 主题配置文件。Hexo 安装主题的方式非常简单，将主题文件下载下来，然后放到theme文件夹里，然后修改下配置文件即可。打开 站点配置文件，找到 theme 字段，并将其值更改为你自己的主题文件即可。这里有一个坑，由于hexo主题文件都是存放在git上的，有个人会通过git clone的方式下载主题文件，但是这样就会在你自己的本地仓库加上这个操作，导致你想要push这个项目时，无法push主题文件。所以一定要下载压缩包然后手动添加到theme文件夹中。验证主题是否启用运行 hexo s –debug ，并访问4000端口 ，确保站点正确运行。可以先clean一下再运行。六、关于404页面只需在source目录下新建404.html文件即可。代码可以用腾讯公益的404123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; &lt;meta name=\"robots\" content=\"all\" /&gt; &lt;meta name=\"robots\" content=\"index,follow\"/&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"回到我的主页\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;七、使用过程遇到的问题一篇文章添加多个标签tags: [标签1,标签2,标签3]Front-matter参数描述默认值layout布局title标题date建立日期文件建立日期updated更新日期文件更新日期comments开启文章的评论功能truetags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址八、hexo 偶尔抽风123&#123; [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;Try to install with –no-optional option.1$ npm install hexo --no-optional","updated":"2016-08-26T08:22:00.000Z","categories":[],"tags":[]}]